<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiered Principles</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #voiceover {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2vw;
            color: rgba(255,255,255,0.8);
            font-family: 'Helvetica', sans-serif;
            text-align: center;
            opacity: 0;
        }
        #title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4vw;
            font-weight: 900;
            color: #fff;
            letter-spacing: 1vw;
            text-transform: uppercase;
            font-family: 'Helvetica', sans-serif;
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="voiceover">Our values travel everywhere...</div>
    <div id="title">TIERED PRINCIPLES</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const voiceEl = document.getElementById('voiceover');
        const titleEl = document.getElementById('title');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let startTime = null;
        let audioStarted = false;
        
        // Tile tones - creating harmonic/silent contrast
        const tiles = [];
        const toneScale = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'];
        
        for (let i = 0; i < 12; i++) {
            const synth = new Tone.Synth({ 
                oscillator: { type: 'sine' },
                envelope: { attack: 0.1, sustain: 0.3, release: 0.5 }
            }).toDestination();
            synth.volume.value = -25;
            tiles.push({
                synth,
                note: toneScale[i % toneScale.length],
                muted: false
            });
        }
        
        document.body.addEventListener('click', async () => {
            if (!audioStarted) {
                await Tone.start();
                startTime = Date.now();
                audioStarted = true;
                
                // Voiceover
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance("Our values travel everywhere");
                    utterance.rate = 0.8;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.6;
                    setTimeout(() => speechSynthesis.speak(utterance), 500);
                }
                
                // Initial tile harmony
                setTimeout(() => {
                    tiles.forEach((tile, i) => {
                        setTimeout(() => {
                            if (!tile.muted) tile.synth.triggerAttackRelease(tile.note, '0.3');
                        }, i * 100);
                    });
                }, 2000);
                
                // Mute tiles progressively
                setTimeout(() => {
                    const mutePattern = [0, 2, 4, 5, 7, 9, 10, 11, 1, 3, 6];
                    mutePattern.forEach((idx, i) => {
                        setTimeout(() => {
                            tiles[idx].muted = true;
                        }, i * 300);
                    });
                }, 4000);
                
                animate();
            }
        });
        
        let globeRotation = 0;
        let hexGrid = [];
        
        // Create hex grid
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            hexGrid.push({
                angle,
                active: true,
                brightness: 1
            });
        }
        
        function drawGlobe(t) {
            if (t > 3) return;
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = 150;
            
            globeRotation += 0.02;
            
            // Gold foil globe
            const gradient = ctx.createRadialGradient(
                cx - 30, cy - 30, 0,
                cx, cy, radius
            );
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(0.5, '#ffed4e');
            gradient.addColorStop(1, '#d4af37');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Meridian lines
            ctx.strokeStyle = 'rgba(200,150,0,0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI + globeRotation;
                ctx.beginPath();
                ctx.ellipse(cx, cy, radius * Math.abs(Math.cos(angle)), radius, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function drawHexGrid(t) {
            if (t < 3) return;
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const baseRadius = 150;
            const rotationSpeed = Math.min(5, (t - 3) * 0.5);
            globeRotation += rotationSpeed * 0.05;
            
            // Mute spread calculation
            const muteProgress = Math.min(1, (t - 4) / 3);
            
            hexGrid.forEach((hex, i) => {
                const angle = hex.angle + globeRotation;
                const radius = baseRadius + Math.sin(angle * 3) * 20;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                // Determine if muted (spreading pattern)
                const distanceFromMuteOrigin = Math.abs(i - 8);
                const shouldMute = muteProgress > (distanceFromMuteOrigin / 12);
                
                const brightness = shouldMute ? 0.1 : 1;
                const color = i === 8 ? '#ff0000' : `rgba(100,200,255,${brightness})`;
                
                // Draw hex
                ctx.fillStyle = color;
                ctx.beginPath();
                for (let v = 0; v < 6; v++) {
                    const vAngle = (v / 6) * Math.PI * 2;
                    const vx = x + Math.cos(vAngle) * 30;
                    const vy = y + Math.sin(vAngle) * 30;
                    if (v === 0) ctx.moveTo(vx, vy);
                    else ctx.lineTo(vx, vy);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Play tone if active
                if (t > 4 && Math.floor(t * 10) !== Math.floor((t - 0.016) * 10)) {
                    if (!shouldMute && Math.random() > 0.7) {
                        tiles[i].synth.triggerAttackRelease(tiles[i].note, '0.1');
                    }
                }
            });
        }
        
        function drawZoom(t) {
            if (t < 6.5) return;
            
            const zoomProgress = (t - 6.5) / 1.5;
            const scale = 1 + zoomProgress * 10;
            
            ctx.fillStyle = `rgba(0,0,0,${zoomProgress})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Red tile zooms
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const size = 50 * scale;
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(cx - size / 2, cy - size / 2, size, size);
        }
        
        function updateVoiceover(t) {
            if (t > 0.5 && t < 3) {
                voiceEl.style.opacity = 1;
            } else {
                voiceEl.style.opacity = 0;
            }
        }
        
        function updateTitle(t) {
            if (t > 7) {
                titleEl.style.opacity = Math.min(1, (t - 7) * 2);
            }
        }
        
        function animate() {
            if (!startTime) return;
            const elapsed = (Date.now() - startTime) / 1000;
            if (elapsed > 8) return;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGlobe(elapsed);
            drawHexGrid(elapsed);
            drawZoom(elapsed);
            updateVoiceover(elapsed);
            updateTitle(elapsed);
            
            requestAnimationFrame(animate);
        }
        
        ctx.fillStyle = '#ffd700';
        ctx.font = '20px Helvetica';
        ctx.textAlign = 'center';
        ctx.fillText('CLICK TO START', canvas.width / 2, canvas.height / 2);
    </script>
</body>
</html>
