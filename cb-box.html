<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Negotiation Field ‚Äî Ethical Practice Simulator</title>
  <style>
    /* ========== COLOR THEME SYSTEM ========== */
    /* Default: Dark theme with sky blue accents */
    :root{--bg:#0b0b0b;--fg:#f5f5f5;--muted:#bdbdbd;--accent:#7dd3fc;--good:#86efac;--warn:#fbbf24;--bad:#f87171;--card:#161616;--line:#262626;--paper:#f8f7f3;--ink:#1b1b1b;--paper-muted:#57534e}
    
    /* Light & Neutral Themes */
    [data-theme="light"]{--bg:#ffffff;--fg:#111827;--muted:#6b7280;--accent:#2563eb;--card:#f3f4f6;--line:#e5e7eb}
    [data-theme="news"]{--bg:var(--paper);--fg:var(--ink);--muted:var(--paper-muted);--accent:#0f172a;--card:#fff;--line:#e7e5e4}
    
    /* Agricultural & Earth Tones */
    [data-theme="earth"]{--bg:#1a1510;--fg:#e8dcc8;--muted:#9a8b72;--accent:#d4a574;--good:#8fbc8f;--warn:#e8b65d;--bad:#d17a5c;--card:#2d2419;--line:#3d342a}
    [data-theme="field"]{--bg:#0f1410;--fg:#d4e3d0;--muted:#7a9175;--accent:#6b9b6f;--good:#8fbc8f;--warn:#c9a55a;--bad:#b66d5c;--card:#1a221c;--line:#2d3a2f}
    [data-theme="catalog"]{--bg:#f5f1e8;--fg:#2d2419;--muted:#6b5d4f;--accent:#8b6f47;--good:#6b8e5c;--warn:#c9a55a;--bad:#a84e3d;--card:#ebe4d5;--line:#cdc2ad}
    
    /* Natural Palettes */
    [data-theme="ocean"]{--bg:#0a1628;--fg:#e0f2fe;--muted:#7dd3fc;--accent:#38bdf8;--good:#86efac;--warn:#fbbf24;--bad:#f87171;--card:#1e293b;--line:#334155}
    [data-theme="forest"]{--bg:#0f1a0f;--fg:#d4e8d4;--muted:#86a886;--accent:#6b9b6f;--good:#8fbc8f;--warn:#d4a574;--bad:#c17a5c;--card:#1a2b1a;--line:#2d3f2d}
    [data-theme="sunset"]{--bg:#1a0f0a;--fg:#ffe8d4;--muted:#d4a574;--accent:#f59e0b;--good:#86efac;--warn:#fbbf24;--bad:#f87171;--card:#2b1a14;--line:#3f2d24}
    
    /* Developer Themes */
    [data-theme="terminal"]{--bg:#000000;--fg:#00ff00;--muted:#00aa00;--accent:#00ff00;--good:#00ff00;--warn:#ffff00;--bad:#ff0000;--card:#0a0a0a;--line:#003300}
    [data-theme="solarized"]{--bg:#002b36;--fg:#839496;--muted:#586e75;--accent:#268bd2;--good:#859900;--warn:#b58900;--bad:#dc322f;--card:#073642;--line:#094653}
    [data-theme="dracula"]{--bg:#282a36;--fg:#f8f8f2;--muted:#6272a4;--accent:#8be9fd;--good:#50fa7b;--warn:#f1fa8c;--bad:#ff5555;--card:#44475a;--line:#6272a4}
    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial;
      display: flex;
      flex-direction: column;
    }
    /* Center Observer radar/canvas on mobile */
    #observerPanel canvas{ display:block; margin-left:auto; margin-right:auto; max-width:92vw; height:auto }
    #observerPanel .chart, #observerPanel .radarWrap{ display:flex; justify-content:center }
    #observerPanel .radarWrap{ width:100% }
    a{color:var(--accent)}
    header{
      position:sticky;
      top:0;
      background:linear-gradient(180deg,var(--bg),rgba(0,0,0,0));
      backdrop-filter:saturate(1.4) blur(8px);
      -webkit-backdrop-filter:saturate(1.4) blur(8px); /* For Safari */
      z-index:10;
      border-bottom:1px solid var(--line);
      flex-shrink: 0;
    }
    header .bar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding: 8px 12px;
      flex-wrap: wrap; /* Allow wrapping for flow controls */
    }
    .title{display:flex;gap:10px;align-items:center;position:relative}
    .logo{width:32px;height:32px;border-radius:10px;box-shadow:0 0 0 1px var(--line) inset;display:grid;place-items:center;cursor:pointer;transition:box-shadow .2s ease, transform .2s ease}
    .logo:focus{outline:2px solid var(--line)}
    .logoWord{display:none;font-weight:600;font-size:14px;letter-spacing:.2px}
    body.palette-open .logoWord{display:inline}
    /* Active pulse using current role tint */
    :root{ --ally:#38bdf8; --keeper:#f59e0b; --good:#86efac; --accent: var(--good) }
    body.current-ally{ --accent: var(--ally) }
    body.current-keeper{ --accent: var(--keeper) }
    @keyframes pulseGlow{ 0%{ box-shadow:0 0 0 1px var(--line) inset, 0 0 0 rgba(0,0,0,0)} 50%{ box-shadow:0 0 0 1px var(--line) inset, 0 0 18px var(--accent)} 100%{ box-shadow:0 0 0 1px var(--line) inset, 0 0 0 rgba(0,0,0,0)} }
    body.palette-open .logo{ animation:pulseGlow 1.6s ease-in-out infinite }
    /* Palette panel anchored to logo */
    .palette{position:absolute;left:0;top:calc(100% + 8px);min-width:320px;max-width:92vw;background:var(--card);border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 24px rgba(0,0,0,0.35);padding:10px;display:none;z-index:200}
    .palette.open{display:block}
    .palette .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .palette .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
    @media (max-width:480px){ .palette{min-width:260px} }
    @media (max-width:980px){ .palette-advanced{ display:none } }
    :root{ --ally:#38bdf8; --keeper:#f59e0b; --good:#86efac }
    h1{margin:0;font-size:14px;letter-spacing:.2px;opacity:.9}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:nowrap;overflow-x:hidden;white-space:nowrap}
    .collapsed{display:none !important}
    /* Header menu */
    .menu-wrap{position:relative}
    .menu{position:absolute;left:0;top:calc(100% + 6px);min-width:320px;background:var(--card);border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 24px rgba(0,0,0,0.35);padding:10px;display:none;z-index:220; touch-action:manipulation; -webkit-overflow-scrolling:touch }
    .menu.open{display:block}
    .menu details{border-top:1px dashed var(--line);padding-top:8px;margin-top:8px}
    button, select, input, textarea{background:var(--card);color:var(--fg);border:1px solid var(--line);border-radius:10px;padding:10px 12px;font:inherit}
    @media (max-width:980px){ button, select{ min-height:36px } }
    button{cursor:pointer}
    .pill{padding:6px 10px;border-radius:999px;font-size:12px;white-space:nowrap}
    /* Fixed-width status pills for mobile clarity */
    #turnInfo{min-width:118px; text-align:center; font-variant-numeric: tabular-nums; border: 1px solid var(--line); background: rgba(255,255,255,0.03)}
    #phaseLamp{min-width:94px; text-align:center; border: 1px solid var(--line); background: rgba(255,255,255,0.06); font-weight: 600}
    .statusCluster{display:inline-flex; gap:6px; align-items:center}
    /* Role-tinted status cluster */
    body.current-ally #phaseLamp, body.current-ally #turnInfo{ border-color: rgba(56,189,248,0.6); background: rgba(56,189,248,0.12); color: var(--fg) }
    body.current-keeper #phaseLamp, body.current-keeper #turnInfo{ border-color: rgba(245,158,11,0.6); background: rgba(245,158,11,0.12); color: var(--fg) }
    /* Phase tint: PLAN -> green */
    body.phase-plan #phaseLamp, body.phase-plan #turnInfo{ border-color: rgba(134,239,172,0.65); background: rgba(134,239,172,0.14) }
    /* Tint logo by active role */
    .logo{ color: var(--fg) }
    body.current-ally .logo{ color: var(--ally) }
    body.current-keeper .logo{ color: var(--keeper) }
    main{
      flex:1;
      overflow-y: auto;
      display:grid;
      grid-template-columns:1.1fr 1.1fr .9fr;
      gap:12px;
      padding:12px;
    }
    @media (max-width:980px){
      main{grid-template-columns:1fr; padding-bottom:64px}
      body[data-tab="ally"] #allyPanel{display:flex}
      body[data-tab="ally"] #keeperPanel, body[data-tab="ally"] #observerPanel{display:none}
      body[data-tab="keeper"] #keeperPanel{display:flex}
      body[data-tab="keeper"] #allyPanel, body[data-tab="keeper"] #observerPanel{display:none}
      body[data-tab="observer"] #observerPanel{display:flex}
      body[data-tab="observer"] #allyPanel, body[data-tab="observer"] #keeperPanel{display:none}
      header .controls{gap:6px}
      header .bar{padding:6px 8px}
      h1{font-size:13px}
    }
    .panel{
      display:flex;
      flex-direction:column;
      background:var(--card);
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      min-height: 250px;
    }
    .panel h2{
      margin:0;padding:10px 12px;border-bottom:1px solid var(--line);
      font-size:14px;letter-spacing:.3px;background:rgba(255,255,255,0.02);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .panel h2 .small{ margin-left: auto; }
    .chat{flex:1;display:flex;flex-direction:column;gap:10px;padding:12px;overflow:auto}
    /* Subtle scrollbars and no nested scrollbars */
    .chat{scrollbar-width:thin}
    .chat::-webkit-scrollbar{width:6px}
    .chat::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.2);border-radius:6px}
    .msg{display:flex;gap:8px;align-items:flex-start}
    .msg .who{flex:0 0 auto;width:28px;height:28px;border-radius:10px;display:grid;place-items:center;font-weight:700}
    .ally{background:#38bdf8;color:#00111a}
    .keeper{background:#f59e0b;color:#1a1000}
    .ref{background:#22c55e;color:#00140a}
    /* Ensure role avatar color is correct even if class assignment is inconsistent */
    .msg.role-keeper .who{ background:#f59e0b !important; color:#1a1000 !important }
    .msg.role-ally .who{ background:#38bdf8 !important; color:#00111a !important }
    .bubble{flex:1;padding:10px 12px;border:1px solid var(--line);border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0))}
    /* Role tinted bubbles */
    .msg.role-ally .bubble{background:linear-gradient(180deg, rgba(56,189,248,0.12), rgba(56,189,248,0.04)); border-color: rgba(56,189,248,0.4)}
    .msg.role-keeper .bubble{background:linear-gradient(180deg, rgba(245,158,11,0.12), rgba(245,158,11,0.04)); border-color: rgba(245,158,11,0.4)}
    /* Current speaker emphasis (mobile clarity) */
    body.current-ally .msg.role-ally .bubble{ box-shadow: 0 0 0 2px rgba(56,189,248,0.5) inset }
    body.current-keeper .msg.role-keeper .bubble{ box-shadow: 0 0 0 2px rgba(245,158,11,0.5) inset }
    .inputbar{display:flex;gap:8px;padding:12px;border-top:1px solid var(--line); position:sticky; bottom:0; background:linear-gradient(180deg, rgba(0,0,0,0), var(--card));}
    textarea{flex:1;min-height:96px;max-height:50vh;resize:vertical}
    /* Color-coded send buttons */
    #allySend{background:#38bdf8;color:#00111a;border-color:#38bdf8}
    #allySend:hover{filter:brightness(1.1)}
    #keeperSend{background:#f59e0b;color:#1a1000;border-color:#f59e0b}
    #keeperSend:hover{filter:brightness(1.1)}
    .kpi{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;padding:8px;border-top:1px dashed var(--line);background:rgba(255,255,255,0.02)}
    .kpi .box{padding:6px;border:1px solid var(--line);border-radius:12px}
    .small{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .settings{padding:12px;display:grid;gap:10px;border-top:1px dashed var(--line)}
    .toggle{display:flex;align-items:center;gap:8px}
    canvas.radar{width:100%;height:300px}
    .legend{display:flex;gap:8px;flex-wrap:wrap;padding:8px;border-top:1px dashed var(--line)}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,0.04);font-size:12px}
    .swatch{width:10px;height:10px;border-radius:50%}
    .notice{padding:10px 12px;border-top:1px dashed var(--line);font-size:12px;color:var(--muted)}
    .hl{color:var(--accent);font-weight:600}
    /* Momentum bar */
    .momentum{display:flex;align-items:center;gap:8px;padding:8px;border-top:1px dashed var(--line)}
    .momentum .label{font-size:12px;color:var(--muted)}
    .momentum .bar{flex:1;height:8px;background:var(--line);border-radius:999px;position:relative;overflow:hidden}
    .momentum .fill{position:absolute;top:0;bottom:0;left:0;width:50%;background:linear-gradient(90deg, var(--good), var(--accent));transition:width .25s ease}
    .momentum .ticks{position:absolute;inset:0;display:flex;justify-content:space-between;pointer-events:none}
    .pill.win{background: rgba(34,197,94,0.2); border:1px solid var(--good)}
    .pill.lose{background: rgba(239,68,68,0.15); border:1px solid var(--bad)}
    .ok{color:var(--good)}
    .avatarRow{display:flex;flex-direction:column;gap:6px;padding:6px 10px;border-bottom:1px dashed var(--line);background:rgba(255,255,255,0.02)}
    .miniRow{display:grid;grid-template-columns:1fr;gap:8px}
    canvas.mini{width:100%;height:260px;border-radius:12px;border:1px solid var(--line);background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0)); transition: box-shadow .2s ease}
    canvas.mini.observer-model-style{ box-shadow: 0 0 0 2px var(--good) inset } /* Changed to just highlight observer models */
    canvas.mini.warn{box-shadow: 0 0 0 2px var(--bad) inset}
    /* Compact mode hides heavy settings and extra minis */
    body.compact .settings{display:none}
    body.compact .legend{display:none}
    /* In compact, hide inline system instruction editors */
    body.compact #allySysDD, body.compact #keeperSysDD { display: none }
    /* Use a single mini per agent (layered self behind observer) */
    .avatarRow .miniRow > div:first-child{ display:none }
    /* Agent top: two-column layout (radar | compact stats) */
    .agentTop{display:grid;grid-template-columns:1.2fr .8fr;gap:10px;align-items:start;padding:6px 10px}
    .agentTop .kpi{grid-template-columns:1fr;gap:6px;padding:6px}
    .agentTop .kpi .box{padding:6px}
    /* Lights row */
    .lights{display:flex;gap:10px;align-items:center;padding:6px 10px}
    .light{display:inline-flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)}
    .dotLight{width:10px;height:10px;border-radius:50%;background:#666;box-shadow:0 0 0 2px var(--line) inset}
    .light.on .dotLight{background:var(--good); box-shadow:0 0 10px rgba(34,197,94,0.35)}
    /* System header lines */
    .sysbar{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:6px 10px;border-bottom:1px dashed var(--line)}
    .sysbar select{padding:6px 8px;font-size:12px;border-radius:8px}
    .sysSummary{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .statusbar{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:center;padding:6px 10px;border-bottom:1px dashed var(--line)}
    /* Mobile tab bar */
    .tabbar{position:fixed;bottom:0;left:0;right:0;height:50px;background:var(--card);border-top:1px solid var(--line);display:none;grid-template-columns:repeat(3,1fr);z-index:12}
    .tabbar button{border-radius:0;border:none;display:flex;align-items:center;justify-content:center;font-size:13px}
    @media (max-width:980px){.tabbar{display:grid}}
    @media (max-width:980px){ header h1{ display:none } }
    /* Keep header to two rows on mobile: compress spacing instead of hiding controls */
    @media (max-width:980px){ header .bar{ padding:4px 6px } }
    @media (max-width:980px){ header .controls{ gap:4px; flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch } }
    @media (max-width:980px){ header button, header select{ padding:6px 8px; font-size:12px } }
    @media (max-width:980px){ #flowMode{ width:84px } }
    /* Mobile: hide nonessential controls and use hamburger */
    .hide-mobile{ display:inline-flex }
    @media (max-width:980px){ .hide-mobile{ display:none !important } }
    @media (max-width:980px){ #hamburger{ display:inline-flex } }
    #hamburger{ display:none; align-items:center; justify-content:center; min-width:32px; border:1px solid var(--line); border-radius:8px; background:var(--card) }
    /* Mobile drawer */
    #mobileDrawer{ position:fixed; top:0; right:0; bottom:0; width:280px; background:var(--card); border-left:1px solid var(--line); box-shadow:-10px 0 24px rgba(0,0,0,0.4); z-index:100; transform:translateX(100%); transition:transform .2s ease; display:flex; flex-direction:column }
    #mobileDrawer.open{ transform:translateX(0) }
    #mobileDrawer header{ padding:12px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center }
    #mobileDrawer .content{ padding:10px; display:grid; gap:8px }
    .sysbox{display:grid;gap:8px}
    .sysbox textarea{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; min-height:180px}
    .sysGrid{display:grid;grid-template-columns:1fr 320px;gap:10px;align-items:start}
    @media (max-width:980px){.sysGrid{grid-template-columns:1fr}}
    /* Radar theme vars with sensible defaults */
    :root{--radar-grid: rgba(0,0,0,0.18); --radar-label: rgba(0,0,0,0.7); --radar-self: rgba(0,0,0,0.35)}
    .black,:root.dark{--radar-grid: rgba(255,255,255,0.18); --radar-label: rgba(255,255,255,0.85); --radar-self: rgba(255,255,255,0.5)}
    .white,.newspaper{--radar-grid: rgba(0,0,0,0.18); --radar-label: rgba(0,0,0,0.75); --radar-self: rgba(0,0,0,0.35)}
    footer{display:none}
    /* Edit sliders */
    .editGrid{display:grid;grid-template-columns:1fr;gap:6px;margin-top:6px}
    .sliderRow{display:grid;grid-template-columns:56px 1fr 32px;gap:6px;align-items:center}
    .sliderRow input[type=range]{width:100%}
    .progress-bar-container { width: 100%; background: var(--card); border-radius: 4px; overflow: hidden; height: 6px; margin-top: 4px; }
    .progress-bar { height: 100%; background: var(--good); width: 0%; transition: width 0.3s ease-in-out; }
    .loop-risk-bar .progress-bar { background: var(--warn); }
    .loop-risk-bar.high .progress-bar { background: var(--bad); }
    #apiWarning {
      background: var(--bad); color: var(--fg); padding: 8px 12px; border-radius: 8px; margin-top: 10px;
      font-size: 14px; display: none; /* Hidden by default */
    }

    /* Game Over Overlay - Ticket Styling */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      width: clamp(300px, 90vw, 700px);
      max-height: 90vh;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      position: relative;
      /* Ticket-like elements */
      border-left: 8px solid var(--accent); /* Accent stripe */
      padding: 20px;
      gap: 15px;
    }
    .overlay .card header {
      padding: 0;
      border-bottom: 1px solid var(--line);
      padding-bottom: 15px;
      margin-bottom: 15px;
    }
    .overlay .card h3 {
      margin: 0;
      font-size: 24px;
      color: var(--fg);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .overlay .card h3 .pill {
        font-size: 14px;
        padding: 8px 12px;
    }
    .overlay .card h3 .pill.ok {
        background: var(--good);
        color: var(--ink); /* For contrast on light theme */
        border-color: var(--good);
    }
    .overlay .card h3 .pill.err {
        background: var(--bad);
        color: var(--ink); /* For contrast on light theme */
        border-color: var(--bad);
    }
    .overlay .card .content {
      display: grid;
      gap: 20px;
      flex: 1;
    }
    .overlay .card .summary {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      font-size: 14px;
      padding-bottom: 15px;
      border-bottom: 1px dashed var(--line);
    }
    .overlay .card .summary .row {
      justify-content: space-between;
    }
    .overlay .card .summary .row > div:first-child { color: var(--muted); }
    .overlay .card .actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding-top: 20px;
      border-top: 1px solid var(--line);
    }
    .overlay .card .actions button {
      flex: 1;
      max-width: 150px;
      padding: 12px 15px;
    }
    .agent-meta-display {
      background: var(--bg);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 15px;
      display: grid;
      gap: 8px;
    }
    .agent-meta-display h4 {
        margin: 0 0 10px 0;
        font-size: 16px;
        border-bottom: 1px dashed var(--line);
        padding-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .agent-meta-display .thick-poem {
      font-style: italic;
      color: var(--accent);
      margin-bottom: 10px;
      line-height: 1.5;
    }
    .agent-meta-display .line {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 14px;
      align-items: flex-start;
    }
    .agent-meta-display .line strong { color: var(--muted); font-weight: 400; }
    .agent-meta-display .line .value { text-align: right; flex-grow: 1; font-weight: 500;}

    .mini-radar-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        padding-top: 15px;
        border-top: 1px dashed var(--line);
    }
    .mini-radar-container > div {
        text-align: center;
    }

    .adjudication-outcome {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* Styles for structured observer log */
    .observer-log-entry {
        align-items: flex-start;
    }
    .observer-log-entry .bubble {
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
        width: 100%; /* Ensure bubble takes full width */
        display: grid;
        gap: 8px;
    }
    .observer-log-entry .bubble pre {
        white-space: pre-wrap;
        word-break: break-all;
        font-size: 12px;
        background: rgba(0,0,0,0.1);
        padding: 8px;
        border-radius: 8px;
        margin: 0;
    }
    .observer-log-entry .bubble ul {
        margin: 0;
        padding-left: 20px;
        list-style: disc;
    }
    .observer-log-entry .bubble details {
        background: rgba(0,0,0,0.05);
        border-radius: 8px;
        padding: 8px;
        margin-top: 5px;
    }
    .observer-log-entry .bubble summary {
        cursor: pointer;
        font-weight: 600;
        color: var(--accent);
    }

    /* Observer log: role-tag headers and section chips */
    .obs-section {display:flex;align-items:center;gap:8px;margin:6px 0 2px 0}
    .role-chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);font-size:11px}
    .role-chip.ally{background:rgba(56,189,248,0.12);border-color:#0ea5e9;color:#7dd3fc}
    .role-chip.keeper{background:rgba(245,158,11,0.12);border-color:#d97706;color:#fbbf24}
    .role-chip.obs{background:rgba(167,139,250,0.12);border-color:#8b5cf6;color:#c4b5fd}
    .phase-chip{font-size:11px;padding:4px 8px;border-radius:999px;border:1px dashed var(--line);opacity:.9}
    .phase-chip.plan{background:rgba(125,211,252,0.08)}
    .phase-chip.think{background:rgba(167,139,250,0.08)}
    .phase-chip.speak{background:rgba(134,239,172,0.08)}

    /* Typing indicator bubbles for chats */
    .typing{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px dashed var(--line);border-radius:12px;opacity:.85}
    .dot{width:6px;height:6px;border-radius:50%;background:var(--muted);opacity:.7;animation:blink 1.2s infinite ease-in-out}
    .dot:nth-child(2){animation-delay:.2s}
    .dot:nth-child(3){animation-delay:.4s}
    @keyframes blink{0%,80%,100%{transform:translateY(0);opacity:.5}40%{transform:translateY(-2px);opacity:1}}

    /* Compact KPI value pairs */
    .kv{display:grid;grid-template-columns:auto 1fr;gap:4px;font-size:12px}
    .kv .k{color:var(--muted)}
    .kv .v{text-align:right}
  </style>
</head>
<body data-theme="dark">
  <header>
    <div class="bar wrap">
      <div class="title">
        <div class="logo" id="logoBtn" aria-label="Negotiation controls" role="button" tabindex="0">
          <!-- Negotiation Field ¬∑ Mark -->
          <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 128 128" role="img" aria-labelledby="cb-mark">
            <title id="cb-mark">Negotiation Field</title>
            <defs>
              <style>
                :root{ --cb-ink:currentColor; --cb-blue:#38bdf8; --cb-orange:#f59e0b; --cb-green:#86efac; }
                .ink{stroke:var(--cb-ink); fill:none}
              </style>
              <clipPath id="cbClip128">
                <path d="M64 16L96 32V80L64 96L32 80V32Z"/>
              </clipPath>
            </defs>
            <g stroke-linecap="round" stroke-linejoin="round">
              <g class="ink" stroke-width="6">
                <path d="M64 16L96 32V80L64 96L32 80V32Z"/>
                <path d="M64 16V64M32 32L64 48L96 32M64 48V96"/>
              </g>
              <g clip-path="url(#cbClip128)" stroke-width="6" opacity=".98">
                <circle cx="64" cy="43" r="14" stroke="var(--cb-green)" fill="var(--cb-green)" fill-opacity=".22"/>
                <circle cx="52.742" cy="62.5" r="14" stroke="var(--cb-blue)" fill="var(--cb-blue)" fill-opacity=".22"/>
                <circle cx="75.258" cy="62.5" r="14" stroke="var(--cb-orange)" fill="var(--cb-orange)" fill-opacity=".22"/>
              </g>
            </g>
          </svg>
        </div>
        <span id="logoWord" class="logoWord">Field</span>
        <!-- Collapsible palette anchored to logo -->
        <div id="palettePanel" class="palette" aria-hidden="true" role="menu">
          <div class="row">
            <strong style="font-size:12px; color:var(--muted)">Controls</strong>
          </div>
          <div class="row palette-advanced">
            <label class="small">Scenario</label>
            <select id="paletteScenario"></select>
          </div>
          <div class="row palette-advanced">
            <label class="small">Theme</label>
            <select id="paletteTheme">
              <optgroup label="Standard">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="news">Newspaper</option>
              </optgroup>
              <optgroup label="Agricultural">
                <option value="earth">Earth Tones</option>
                <option value="field">Field Green</option>
                <option value="catalog">Seed Catalog</option>
              </optgroup>
              <optgroup label="Natural">
                <option value="ocean">Ocean</option>
                <option value="forest">Forest</option>
                <option value="sunset">Sunset</option>
              </optgroup>
              <optgroup label="Developer">
                <option value="terminal">Terminal</option>
                <option value="solarized">Solarized</option>
                <option value="dracula">Dracula</option>
              </optgroup>
            </select>
          </div>
          <div class="row" style="align-items:center">
            <label class="small">Flow</label>
            <div class="row">
              <button data-flow="manual">MAN</button>
              <button data-flow="confirm">CONF</button>
              <button data-flow="auto">AUTO</button>
            </div>
          </div>
          <div class="grid" style="margin-top:6px">
            <button data-proxy="reset">‚Üª Reset</button>
            <button data-proxy="pause">‚Äñ / ‚ñ∂</button>
            <button data-proxy="next">‚û§ Next</button>
            <button data-proxy="download">‚¨á Log</button>
            <button data-proxy="fullscreen">‚õ∂ Full</button>
            <button data-proxy="record">‚óâ Rec</button>
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:6px">
            <label class="small"><input type="checkbox" id="paletteCompact" /> Compact UI</label>
          </div>
          <div class="row" style="justify-content:space-between; margin-top:6px; border-top:1px dashed var(--line); padding-top:8px">
            <label class="small">Plan count
              <select id="palettePlanCount">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </label>
            <label class="small"><input type="checkbox" id="palettePlanShow" checked /> Header pills</label>
            <label class="small"><input type="checkbox" id="palettePlanAuto" checked /> Auto-pick</label>
          </div>
        </div>
        <!-- Top-left menus -->
        <div class="menu-wrap">
          <button id="modelsMenuBtn" aria-label="Models">‚àë ‚ñæ</button>
          <div id="modelsMenu" class="menu" role="menu" aria-hidden="true">
            <div class="row"><label class="small" for="apiBase">API Base</label><input id="apiBase" placeholder="https://api.openai.com/v1" /></div>
            <div class="row"><label class="small" for="apiKey">API Key</label><input id="apiKey" placeholder="sk-‚Ä¶" /></div>
            <div id="apiWarning">
              <strong>Warning: Missing or invalid API Key!</strong> LLM auto-reply, Modeler, and Strategic Planning will not work.
            </div>
            <div class="row"><label class="small" for="allyModel">ALLY model</label><input id="allyModel" value="gpt-4o-mini" /></div>
            <div class="row"><label class="small" for="keeperModel">GATEKEEPER model</label><input id="keeperModel" value="gpt-4o-mini" /></div>
            <div class="row toggle"><input type="checkbox" id="useLLM" /><label for="useLLM">Enable LLM auto-reply</label></div>
            <div class="row toggle"><input type="checkbox" id="typewriter" /><label for="typewriter">Typewriter effect for AI replies</label></div>
            <div class="row toggle"><input type="checkbox" id="ethics" checked /><label for="ethics">Ethics filter ON</label></div>
            <div class="row toggle"><input type="checkbox" id="useModeler" checked /><label for="useModeler">Use Modeler for belief updates</label></div>
            <div class="row toggle"><input type="checkbox" id="autoConverse" /><label for="autoConverse">LLM Auto-Converse (prefer Flow: Auto)</label></div>
            <div class="row toggle"><input type="checkbox" id="relayMode" checked /><label for="relayMode">Relay completions into other chat</label></div>
            <div class="row toggle"><input type="checkbox" id="strategicPlanningEnabled" checked /><label for="strategicPlanningEnabled">Enable Strategic Planning</label></div>
            <div class="row" style="gap:8px; align-items:center; border-top:1px dashed var(--line); padding-top:8px">
              <label class="small">Scenario
                <select id="modelsScenario"></select>
              </label>
              <label class="small">Theme
                <select id="modelsTheme">
                  <option value="news">Newspaper</option>
                  <option value="light">White</option>
                  <option value="dark">Black</option>
                </select>
              </label>
            </div>
            <details open>
              <summary>Planner options</summary>
              <div class="row" style="gap:8px; align-items:center;">
                <label class="small">Count
                  <select id="planCount">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                  </select>
                </label>
                <label class="small"><input type="checkbox" id="planShowHeader" checked /> Show in header</label>
                <label class="small"><input type="checkbox" id="planAutoPick" checked /> Auto-pick best</label>
              </div>
            </details>
            <div class="row" style="justify-content:flex-end; padding-top:8px; border-top:1px dashed var(--line);">
              <button id="downloadLog">Download Conversation Log</button>
              <button id="helpBtn">Help</button>
            </div>
            <div class="row" style="justify-content:flex-end; padding-top:8px; border-top:1px dashed var(--line);">
              <button id="openExperiment">‚öô Experiment</button>
            </div>
          </div>
        </div>
        <div class="menu-wrap">
          <button id="audioMenuBtn" aria-label="Audio">‚ô™ ‚ñæ</button>
          <div id="audioMenu" class="menu" role="menu" aria-hidden="true">
            <details open>
              <summary>Text-to-Speech (TTS)</summary>
              <div class="row toggle"><input type="checkbox" id="allyTTS" /><label for="allyTTS">ALLY Voice ON</label></div>
              <div class="row toggle"><input type="checkbox" id="keeperTTS" /><label for="keeperTTS">GATEKEEPER Voice ON</label></div>
            </details>
          </div>
        </div>
        <h1>Negotiation Field</h1>
      </div>
      <div class="controls">
        <a href="HUB.html" style="display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; text-decoration:none; font-size:16px;" title="Return to Hub">üè†</a>
        <button id="hamburger" title="Menu">‚â°</button>
        <!-- Status cluster: ALWAYS VISIBLE -->
        <div class="statusCluster">
          <div id="phaseLamp" class="pill" aria-live="polite">Œ¶ IDLE</div>
          <span class="pill" id="turnInfo" title="Turns and elapsed">T0 ‚Ä¢ 00:00</span>
        </div>
        <!-- Mobile tab controls: ALWAYS VISIBLE -->
        <button id="tabStep" title="Cycle tabs (ALLY ‚Üí KEEPER ‚Üí OBSERVER)">‚áÜ</button>
        <button id="autoTabToggle" title="Auto-switch tab to speaking/thinking agent">‚ü≤</button>

        <!-- PLAN options bar (appears only during PLAN) -->
        <div id="planOptionsBar" class="planBar collapsed" title="Planner options (click to choose)" style="display:inline-flex; gap:6px; align-items:center;"></div>

        <select id="scenarioSelect" title="Select Scenario" class="hide-mobile"></select>
        <button id="openExperimentQuick" class="hide-mobile" title="Experiment runner (sweep dimensions)">‚öô</button>
        <select id="theme" class="hide-mobile">
          <option value="news">Newspaper</option>
          <option value="light">White</option>
          <option value="dark">Black</option>
        </select>
        <button id="reset" class="hide-mobile" title="Clear chat and models" aria-label="Reset">‚Üª</button>
        <button id="btnPause" class="hide-mobile" title="Pause/resume autoplay and typing" aria-label="Pause or Play">‚Äñ</button>
        <button id="downloadLogQuick" title="Download conversation log" aria-label="Download">‚¨á</button>
        <!-- NEW: Flow Controls (hidden on mobile) -->
        <div class="flow-controls hide-mobile" style="display:flex; gap:8px; align-items:center;">
            <label style="font-size:12px; white-space:nowrap;" title="Flow mode">
                ‚áÑ
                <select id="flowMode" style="width:100px; padding:6px 10px; border-radius:8px; font-size:12px;">
                    <option value="manual">MAN</option>
                    <option value="confirm">CONF</option>
                    <option value="auto">AUTO</option>
                </select>
            </label>
            <button id="btnNext" class="hide-mobile" style="padding:6px 10px; font-size:12px; white-space:nowrap;" title="Next step">‚û§</button>
            <button id="btnRecord" class="hide-mobile" title="Record screen + audio" aria-label="Record">‚óâ</button>
        </div>
        <!-- Always-visible quick controls -->
        <button id="btnFullscreen" title="Fullscreen" aria-label="Fullscreen">‚õ∂</button>
        <label class="small" style="display:flex; align-items:center; gap:6px;" title="Compact UI">
          <input type="checkbox" id="compactMode" aria-label="Compact UI" />
          <span class="hide-mobile">Compact</span>
        </label>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="panel" id="allyPanel">
      <h2 id="allyPanelTitle"><span id="allyTitleText"></span><span class="small" id="allyTitleSub"></span><span class="small" style="margin-left:auto"></span></h2>
      <!-- System header line 1: system summary + dropdown system instruction + preset + apply -->
        <!-- spacer removed to keep header to exactly two lines -->
        <div class="sysSummary" id="allySysSummary">‚Äî</div>
        <div class="menu-wrap">
          <details id="allySysDD">
            <summary class="small" style="display:flex; align-items:center; gap:8px;">
              <span>System instruction</span>
              <label class="small" style="display:flex; align-items:center; gap:6px;">Preset
                <select id="allyPreset" style="min-width:120px"></select>
              </label>
              <button id="allyPresetSave" class="pill" title="Save current text + sliders as a new preset">Save</button>
              <button id="allyPresetDelete" class="pill" title="Delete selected user preset">Delete</button>
              <button id="allyInlineApply" class="pill">Apply + Recompute</button>
            </summary>
            <div class="sysGrid" style="margin-top:8px;">
              <textarea id="allySys_inline" rows="6" spellcheck="false"></textarea>
              <div class="editGrid" id="allyEditGrid_inline">
                <div class="sliderRow"><span class="small">ope</span><input type="range" min="1" max="5" step="0.1" data-dim="openness"><span class="small" data-val="openness">3</span></div>
                <div class="sliderRow"><span class="small">con</span><input type="range" min="1" max="5" step="0.1" data-dim="conscientious"><span class="small" data-val="conscientious">3</span></div>
                <div class="sliderRow"><span class="small">ext</span><input type="range" min="1" max="5" step="0.1" data-dim="extraversion"><span class="small" data-val="extraversion">3</span></div>
                <div class="sliderRow"><span class="small">agr</span><input type="range" min="1" max="5" step="0.1" data-dim="agreeableness"><span class="small" data-val="agreeableness">3</span></div>
                <div class="sliderRow"><span class="small">neu</span><input type="range" min="1" max="5" step="0.1" data-dim="neuroticism"><span class="small" data-val="neuroticism">3</span></div>
                <div class="sliderRow"><span class="small">log</span><input type="range" min="1" max="5" step="0.1" data-dim="logic"><span class="small" data-val="logic">3</span></div>
                <div class="sliderRow"><span class="small">emp</span><input type="range" min="1" max="5" step="0.1" data-dim="empathy"><span class="small" data-val="empathy">3</span></div>
                <div class="sliderRow"><span class="small">auth</span><input type="range" min="1" max="5" step="0.1" data-dim="authority"><span class="small" data-val="authority">3</span></div>
                <div class="sliderRow"><span class="small">risk</span><input type="range" min="1" max="5" step="0.1" data-dim="risk"><span class="small" data-val="risk">3</span></div>
                <div class="sliderRow"><span class="small">unc</span><input type="range" min="1" max="5" step="0.1" data-dim="uncertainty"><span class="small" data-val="uncertainty">3</span></div>
                <div class="sliderRow"><span class="small">dec</span><input type="range" min="1" max="5" step="0.1" data-dim="decisiveness"><span class="small" data-val="decisiveness">3</span></div>
              </div>
            </div>
          </details>
        </div>
      </div>
      <!-- System header line 2: lights + observer brief -->
      <div class="statusbar">
        <div class="lights">
          <span class="light" id="allyLightAuto"><span class="dotLight"></span> Auto‚Äëreply</span>
          <span class="light" id="allyLightVoice"><span class="dotLight"></span> Voice</span>
        </div>
        <div class="sysSummary"><strong class="small">Observer ‚Üí Gatekeeper:</strong> <span id="allyModelBrief">‚Äî</span></div>
      </div>
      <!-- Move details BELOW radar to keep only two lines above -->
      <div class="agentTop">
        <div>
          <div class="avatarRow">
            <div class="miniRow">
              <div>
                <canvas class="mini" id="allySelfMini"></canvas>
                <div class="small">ALLY self-model</div>
              </div>
              <div>
                <canvas class="mini" id="allyMini"></canvas>
                <div class="small">Observer ‚Üí ALLY (current belief)</div>
              </div>
            </div>
          </div>
        </div>
        <div>
          <div class="kpi">
            <div class="box"><div class="small">Tone</div><div id="allyTone">‚Äî</div></div>
            <div class="box"><div class="small">Progress</div><div id="allyProgress">‚Äî</div></div>
            <div class="box"><div class="small">Last Act</div><div id="allyLastAct">‚Äî</div></div>
          </div>
        </div>
      </div>
      <!-- Removed below system details: now inline beside header -->
      <div class="chat" id="allyChat" aria-live="polite"></div>
      <div class="inputbar">
        <textarea id="allyInput" placeholder="Type as the ALLY‚Ä¶"></textarea>
        <button id="allySend">Send</button>
      </div>
    </section>

    <section class="panel" id="keeperPanel">
      <h2 id="keeperPanelTitle"><span id="keeperTitleText"></span><span class="small" id="keeperTitleSub"></span><span class="small" style="margin-left:auto"></span></h2>
      <!-- System header line 1: system summary + dropdown system instruction + preset + apply -->
        <div class="div"></div>
        <div class="sysSummary" id="keeperSysSummary">‚Äî</div>
        <div class="menu-wrap">
          <details id="keeperSysDD">
            <summary class="small" style="display:flex; align-items:center; gap:8px;">
              <span>System instruction</span>
              <label class="small" style="display:flex; align-items:center; gap:6px;">Preset
                <select id="keeperPreset" style="min-width:120px"></select>
              </label>
              <button id="keeperPresetSave" class="pill" title="Save current text + sliders as a new preset">Save</button>
              <button id="keeperPresetDelete" class="pill" title="Delete selected user preset">Delete</button>
              <button id="keeperInlineApply" class="pill">Apply + Recompute</button>
            </summary>
            <div class="sysGrid" style="margin-top:8px;">
              <textarea id="keeperSys_inline" rows="6" spellcheck="false"></textarea>
              <div class="editGrid" id="keeperEditGrid_inline">
                <div class="sliderRow"><span class="small">ope</span><input type="range" min="1" max="5" step="0.1" data-dim="openness"><span class="small" data-val="openness">3</span></div>
                <div class="sliderRow"><span class="small">con</span><input type="range" min="1" max="5" step="0.1" data-dim="conscientious"><span class="small" data-val="conscientious">3</span></div>
                <div class="sliderRow"><span class="small">ext</span><input type="range" min="1" max="5" step="0.1" data-dim="extraversion"><span class="small" data-val="extraversion">3</span></div>
                <div class="sliderRow"><span class="small">agr</span><input type="range" min="1" max="5" step="0.1" data-dim="agreeableness"><span class="small" data-val="agreeableness">3</span></div>
                <div class="sliderRow"><span class="small">neu</span><input type="range" min="1" max="5" step="0.1" data-dim="neuroticism"><span class="small" data-val="neuroticism">3</span></div>
                <div class="sliderRow"><span class="small">log</span><input type="range" min="1" max="5" step="0.1" data-dim="logic"><span class="small" data-val="logic">3</span></div>
                <div class="sliderRow"><span class="small">emp</span><input type="range" min="1" max="5" step="0.1" data-dim="empathy"><span class="small" data-val="empathy">3</span></div>
                <div class="sliderRow"><span class="small">auth</span><input type="range" min="1" max="5" step="0.1" data-dim="authority"><span class="small" data-val="authority">3</span></div>
                <div class="sliderRow"><span class="small">risk</span><input type="range" min="1" max="5" step="0.1" data-dim="risk"><span class="small" data-val="risk">3</span></div>
                <div class="sliderRow"><span class="small">unc</span><input type="range" min="1" max="5" step="0.1" data-dim="uncertainty"><span class="small" data-val="uncertainty">3</span></div>
                <div class="sliderRow"><span class="small">dec</span><input type="range" min="1" max="5" step="0.1" data-dim="decisiveness"><span class="small" data-val="decisiveness">3</span></div>
              </div>
            </div>
          </details>
        </div>
      </div>
      <!-- System header line 2: lights + observer brief -->
      <div class="statusbar">
        <div class="lights">
          <span class="light" id="keeperLightAuto"><span class="dotLight"></span> Auto‚Äëreply</span>
          <span class="light" id="keeperLightVoice"><span class="dotLight"></span> Voice</span>
        </div>
        <div class="sysSummary"><strong class="small">Observer ‚Üí Ally:</strong> <span id="keeperModelBrief">‚Äî</span></div>
      </div>
      <!-- Move details BELOW radar to keep only two lines above -->
      <div class="agentTop">
        <div>
          <div class="avatarRow">
            <div class="miniRow">
              <div>
                <canvas class="mini" id="keeperSelfMini"></canvas>
                <div class="small">GATEKEEPER self-model</div>
              </div>
              <div>
                <canvas class="mini" id="keeperMini"></canvas>
                <div class="small">Observer ‚Üí GATEKEEPER (current belief)</div>
              </div>
            </div>
          </div>
        </div>
        <div>
          <div class="kpi">
            <div class="box"><div class="small">Tone</div><div id="keeperTone">‚Äî</div></div>
            <div class="box"><div class="small">Caution</div><div id="keeperCaution">‚Äî</div></div>
            <div class="box"><div class="small">Refusals</div><div id="keeperRefusals">‚Äî</div></div>
            <div class="box"><div class="small">Last Act</div><div id="keeperLastAct">‚Äî</div></div>
          </div>
        </div>
      </div>
      <!-- Removed below system details: now inline beside header -->
      <div class="chat" id="keeperChat" aria-live="polite"></div>
      <div class="inputbar">
        <textarea id="keeperInput" placeholder="Type as the GATEKEEPER‚Ä¶"></textarea>
        <button id="keeperSend">Send</button>
      </div>
    </section>

    <section class="panel" id="observerPanel">
      <h2>OBSERVER <span class="small">analytics (PLoT + Barthes)</span></h2>
      <div class="settings sysbox">
        <details>
          <summary>OBSERVER system instruction</summary>
          <div class="row">
            <label class="small" for="observerSysPreset">Preset</label>
            <select id="observerSysPreset"></select>
          </div>
          <textarea id="observerSys" rows="12" spellcheck="false"></textarea>
        </details>
        <details>
          <summary>STRATEGIC PLANNER system instruction</summary>
          <div class="row">
            <label class="small" for="plannerSysPreset">Preset</label>
            <select id="plannerSysPreset"></select>
          </div>
          <textarea id="plannerSys" rows="10" spellcheck="false"></textarea>
        </details>
      </div>
      <canvas class="radar" id="radar"></canvas>
      <div class="legend" id="legend"></div>
      <div class="momentum" title="Momentum reflects the Observer's estimated influence each side has had on the Gatekeeper's beliefs, nudging them towards Release (Ally ‚Üë) or Hold (Gatekeeper ‚Üë).">
        <span class="label">Momentum</span>
        <div class="bar"><div class="fill" id="momentumFill" style="width:50%"></div></div>
        <span class="label" id="momentumWho">‚Äî</span>
      </div>
      <!-- Observer Narrative Box -->
      <div class="notice" id="observerNarrative" style="margin-top: 10px; border-radius: 12px; background: rgba(255,255,255,0.02); border: 1px solid var(--line); padding: 10px 12px; display: block; min-height: 40px; font-style: italic; color: var(--fg);">
        Observer Narrative (Last Model Update): No narrative yet.
      </div>
      <!-- PLAN Options Panel (Manual mode selection) -->
      <div id="planOptionsPanel" class="notice" style="display:none; margin-top:10px; border-radius:12px; border:1px solid var(--line);">
        <div class="row" style="align-items:center; gap:8px; padding:6px 10px; border-bottom:1px dashed var(--line)">
          <strong style="font-size:12px;">Plan options</strong>
          <span class="small" id="planOptionsHint">Select one to proceed</span>
        </div>
        <div id="planOptionsList" style="display:flex; gap:8px; flex-wrap:wrap; padding:8px 10px;"></div>
      </div>
      <div class="row" style="padding:6px 10px; justify-content:flex-end;">
        <label class="small" style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="obsPinBottom" checked> Pin to bottom</label>
      </div>
      <div class="chat" id="obsFeed"></div>
    </section>
  </main>

  <!-- Mobile Drawer -->
  <aside id="mobileDrawer" aria-hidden="true" aria-label="Menu">
    <header>
      <div>Menu</div>
      <button id="drawerClose" aria-label="Close">‚úï</button>
    </header>
    <div class="content">
      <div class="row" style="gap:8px; align-items:center;">
        <label class="small">Scenario</label>
        <select id="drawerScenario"></select>
      </div>
      <div class="row" style="gap:8px; align-items:center;">
        <label class="small">Theme</label>
        <select id="drawerTheme">
          <option value="news">Newspaper</option>
          <option value="light">White</option>
          <option value="dark">Black</option>
        </select>
      </div>
      <div class="row" style="gap:6px; align-items:center;">
        <label class="small">Flow</label>
        <div class="row" style="gap:6px;">
          <button data-flow="manual">MAN</button>
          <button data-flow="confirm">CONF</button>
          <button data-flow="auto">AUTO</button>
        </div>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        <button id="drawerReset">‚Üª Reset</button>
        <button id="drawerPause">‚Äñ / ‚ñ∂</button>
        <button id="drawerNext">‚û§ Next</button>
        <button id="drawerDownload">‚¨á Download</button>
        <button id="drawerFullscreen">‚õ∂ Fullscreen</button>
        <button id="drawerRecord">‚óâ Record</button>
        <label class="small"><input type="checkbox" id="drawerCompact" /> Compact UI</label>
      </div>
    </div>
  </aside>

  <!-- Experiment Runner Overlay -->
  <div id="experimentOverlay" class="overlay" style="display:none;">
    <div class="card" role="dialog" aria-modal="true" aria-labelledby="experimentTitle">
      <header>
        <h3 id="experimentTitle">Experiment Runner <span class="pill" style="font-size:12px;">beta</span></h3>
      </header>
      <div class="content">
        <div class="notice" style="border-radius:8px;">
          This tool sweeps self-model dimensions to study difficulty (release rate, turns). Manual controls remain unchanged. Use this when you want to test how changing authority/risk/decisiveness, etc., affects outcomes.
        </div>
        <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
          <label class="small">Role
            <select id="expRole">
              <option value="ALLY">ALLY</option>
              <option value="KEEPER">KEEPER</option>
            </select>
          </label>
          <label class="small">Dimension
            <select id="expDim">
              <option value="authority">authority</option>
              <option value="risk">risk</option>
              <option value="decisiveness">decisiveness</option>
              <option value="uncertainty">uncertainty</option>
              <option value="conscientious">conscientious</option>
              <option value="openness">openness</option>
              <option value="logic">logic</option>
              <option value="empathy">empathy</option>
            </select>
          </label>
          <label class="small">Start <input id="expStart" type="number" min="1" max="5" step="0.1" value="2.0" /></label>
          <label class="small">End <input id="expEnd" type="number" min="1" max="5" step="0.1" value="5.0" /></label>
          <label class="small">Step <input id="expStep" type="number" min="0.1" max="2" step="0.1" value="0.5" /></label>
          <label class="small">Runs/step <input id="expRuns" type="number" min="1" max="20" step="1" value="3" /></label>
        </div>
        <div class="actions">
          <button id="expRun">Run</button>
          <button id="expClose">Close</button>
        </div>
        <div class="notice small" id="expNote">
          Note: This beta exports a CSV-like text in the console and logs outcomes. A richer report/export can be added.
        </div>
      </div>
    </div>
  </div>
  <!-- Mobile Tab Bar -->
  <div class="tabbar" role="tablist" aria-label="Agents">
    <button data-switch-tab="ally" aria-label="Show Ally">ALLY</button>
    <button data-switch-tab="keeper" aria-label="Show Gatekeeper">GATE</button>
    <button data-switch-tab="observer" aria-label="Show Observer">OBS</button>
  </div>

  <!-- Help Modal -->
  <div class="overlay" id="helpOverlay" style="display:none" aria-modal="true" role="dialog">
    <div class="card" style="max-width:820px">
      <header><h3>Help</h3></header>
      <div class="content">
        <div>
          <p class="small">Quick overview of controls and policies. Use Tools ‚ñæ to configure API, models, and voices. Sequencer modes: Manual, Confirm, Auto.</p>
        </div>
      </div>
      <div class="actions">
        <button id="helpClose">Close</button>
      </div>
    </div>
  </div>

  <footer class="wrap" style="padding:12px; color:var(--muted); font-size:12px;">
    Made by Watson Hartsoe ‚Ä¢ MIT License
  </footer>

  <!-- Game Over Overlay -->
  <div class="overlay" id="gameOverOverlay" aria-modal="true" role="dialog">
    <div class="card">
      <header>
        <h3 id="gameOverTitle">Outcome <span class="pill" id="goBadge">‚Äî</span></h3>
      </header>
      <div class="content">
        <div id="gameOverSubtitle" class="small">‚Äî</div>
        <div class="summary" id="gameOverSummary">
          <div class="row"><div>Scenario</div><div id="goScenario">‚Äî</div></div>
          <div class="row"><div>Turns</div><div id="goTurns">‚Äî</div></div>
          <div class="row"><div>Fatigue Index</div><div id="goFatigue">‚Äî</div></div>
          <div class="row"><div>Momentum Final</div><div id="goMomentum">‚Äî</div></div>
        </div>

        <div class="agent-meta-display" id="allyMetaDisplay">
          <h4>ALLY (Observed Model)</h4>
          <div class="thick-poem" id="allyThickPoem">‚Äî</div>
          <div class="line"><strong>Goal:</strong> <span class="value" id="allyGoal">‚Äî</span></div>
          <div class="line"><strong>Infer Other Goal:</strong> <span class="value" id="allyOtherGoal">‚Äî</span></div>
          <div class="line"><strong>Blocker:</strong> <span class="value" id="allyBlocker">‚Äî</span></div>
          <div class="line"><strong>Shift:</strong> <span class="value" id="allyShift">‚Äî</span></div>
          <div class="line"><strong>Archetypes:</strong> <span class="value" id="allyArchetypes">‚Äî</span></div>
        </div>

        <div class="agent-meta-display" id="keeperMetaDisplay">
            <h4>GATEKEEPER (Observed Model)</h4>
            <div class="thick-poem" id="keeperThickPoem">‚Äî</div>
            <div class="line"><strong>Goal:</strong> <span class="value" id="keeperGoal">‚Äî</span></div>
            <div class="line"><strong>Infer Other Goal:</strong> <span class="value" id="keeperOtherGoal">‚Äî</span></div>
            <div class="line"><strong>Blocker:</strong> <span class="value" id="keeperBlocker">‚Äî</span></div>
            <div class="line"><strong>Shift:</strong> <span class="value" id="keeperShift">‚Äî</span></div>
            <div class="line"><strong>Archetypes:</strong> <span class="value" id="keeperArchetypes">‚Äî</span></div>
        </div>
        
        <div class="mini-radar-container" id="goMiniRadars">
            <div>
                <canvas class="mini" id="goAllyMini"></canvas>
                <div class="small">Final Observer ‚Üí ALLY</div>
            </div>
            <div>
                <canvas class="mini" id="goKeeperMini"></canvas>
                <div class="small">Final Observer ‚Üí GATEKEEPER</div>
            </div>
        </div>

      </div>
      <div class="actions">
        <button id="goDownload">Download Log</button>
        <button id="goReset">Play Again</button>
      </div>
    </div>
  </div>

<script>
/**
 * =====================================================
 * NEGOTIATION FIELD - ETHICAL PRACTICE SIMULATOR
 * =====================================================
 * 
 * A single-file web app for practicing workplace ethical negotiations
 * through AI-powered role-play scenarios.
 * 
 * KEY CONCEPTS:
 * - ALLY:     Individual practitioner seeking ethical change
 * - KEEPER:   Authority figure representing structural constraints  
 * - SCENARIO: Pre-defined conflict with character profiles + prompts
 * - TURN:     One complete exchange (ALLY speaks ‚Üí KEEPER responds)
 * - PHASE:    Sub-step within turn (PLAN ‚Üí THINK ‚Üí SPEAK)
 * 
 * DATA FLOW:
 * 1. User selects scenario ‚Üí loads character profiles
 * 2. User or AI sends message
 * 3. Sequencer triggers PLAN phase (AI generates 3-5 response options)
 * 4. Sequencer triggers THINK phase (AI selects best option with reasoning)
 * 5. Sequencer triggers SPEAK phase (response delivered to chat)
 * 6. Personality profiles updated based on message content
 * 7. Radar charts re-rendered with new personality state
 * 8. Turn advances, cycle repeats
 * 
 * ARCHITECTURE:
 * - Sequencer class:    Turn-based flow controller
 * - Bus class:          Event pub/sub system for component communication
 * - LLM functions:      OpenAI API integration (planning, generation, modeling)
 * - UI controllers:     Chat rendering, radar charts, panel management
 * - SCENARIOS array:    All scenario definitions (see schema below)
 * 
 * STATE MANAGEMENT:
 * - LocalStorage:       API keys, model names, theme preference
 * - Global variables:   currentScenario, allyBelief, keeperBelief
 * - Sequencer instance: turn count, phase, conversation history
 * - DOM:                Chat messages (DOM as database), active theme/tab
 * 
 * TECH STACK:
 * - Vanilla JS (ES6+), no frameworks
 * - OpenAI API (GPT-4o-mini or better)
 * - SVG for personality radar visualization
 * - CSS custom properties for theming
 * 
 * =====================================================
 */
(function(){
  // =====================================================
  // SECTION 1: DOM REFERENCES & INITIAL SETUP
  // =====================================================
  const $ = id => document.getElementById(id);
  const allyChat=$('allyChat'), keeperChat=$('keeperChat'), obsFeed=$('obsFeed');
  const allyInput=$('allyInput'), keeperInput=$('keeperInput');
  const allySend=$('allySend'), keeperSend=$('keeperSend'); 
  const allySys=$('allySys'), keeperSys=$('keeperSys');
  const observerSys = $('observerSys');
  const plannerSys = $('plannerSys');
  const allySysPreset = $('allySysPreset');
  const keeperSysPreset = $('keeperSysPreset');
  const observerSysPreset = $('observerSysPreset');
  const plannerSysPreset = $('plannerSysPreset');
  const allyModelBrief=$('allyModelBrief'), keeperModelBrief=$('keeperModelBrief');
  const allyTone=$('allyTone'), keeperTone=$('keeperTone');
  const radarEl = $('radar');
  const allyMini = $('allyMini');
  const keeperMini = $('keeperMini');
  const allySelfMini = $('allySelfMini');
  const keeperSelfMini = $('keeperSelfMini');
  const turnInfo = $('turnInfo');
  const apiBase=$('apiBase'), apiKey=$('apiKey'), useLLM=$('useLLM');
  const allyModel=$('allyModel'), keeperModel=$('keeperModel'); 
  const ethicsToggle = $('ethics');
  const themeSel = $('theme');
  const resetBtn = $('reset');
  const useModeler = $('useModeler');
  const scenarioSelect = $('scenarioSelect');
  const downloadLogBtn = $('downloadLog');
  const apiWarning = $('apiWarning');
  // Game Over overlay elements
  const goOverlay = $('gameOverOverlay');
  const goTitle = $('gameOverTitle');
  const goSubtitle = $('gameOverSubtitle'); // Corrected ID
  const goScenario = $('goScenario');
  const goTurns = $('goTurns');
  const goFatigue = $('goFatigue');
  const goMomentum = $('goMomentum');
  const goBadge = $('goBadge');
  const goReset = $('goReset');
  const goDownload = $('goDownload');
  
  const allyPanelH2 = $('allyPanelTitle');
  const keeperPanelH2 = $('keeperPanelTitle');

  const allyTTS = $('allyTTS');
  const keeperTTS = $('keeperTTS');
  const allyTTSStatus = $('allyTTSStatus');
  const keeperTTSStatus = $('keeperTTSStatus');
  let speechVoices = [];
  let allyVoice = null;
  let keeperVoice = null;

  const autoConverseToggle = $('autoConverse'); 
  const relayModeToggle = $('relayMode'); 
  const strategicPlanningEnabledToggle = $('strategicPlanningEnabled');

  // Game Over meta displays
  const allyThickPoem = $('allyThickPoem');
  const allyGoal = $('allyGoal');
  const allyOtherGoal = $('allyOtherGoal');
  const allyBlocker = $('allyBlocker');
  const allyShift = $('allyShift');
  const allyArchetypes = $('allyArchetypes');

  const keeperThickPoem = $('keeperThickPoem');
  const keeperGoal = $('keeperGoal');
  const keeperOtherGoal = $('keeperOtherGoal');
  const keeperBlocker = $('keeperBlocker');
  const keeperShift = $('keeperShift');
  const keeperArchetypes = $('keeperArchetypes');

  const goAllyMini = $('goAllyMini');
  const goKeeperMini = $('goKeeperMini');

  // NEW: Flow Control UI elements
  const flowModeSelect = $('flowMode');
  const btnNext = $('btnNext');
  const phaseLamp = $('phaseLamp');
  const observerNarrative = $('observerNarrative');
  // Top-left menus (Models, Audio)
  const modelsMenuBtn = $('modelsMenuBtn');
  const modelsMenu = $('modelsMenu');
  if (modelsMenuBtn && modelsMenu) {
    modelsMenuBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      modelsMenu.classList.toggle('open');
      modelsMenu.setAttribute('aria-hidden', modelsMenu.classList.contains('open') ? 'false' : 'true');
      // Close audio if open
      const am = document.getElementById('audioMenu'); if (am) am.classList.remove('open');
      // Close palette and drawer when opening models
      const p = document.getElementById('palettePanel'); if (p) p.classList.remove('open'); document.body.classList.remove('palette-open');
      const d = document.getElementById('mobileDrawer'); if (d) d.classList.remove('open');
      blockClickCloseUntil = Date.now() + 120;
    });
    // Prevent inside taps from closing
    modelsMenu.addEventListener('click', e=> e.stopPropagation());
    modelsMenu.addEventListener('touchstart', e=> e.stopPropagation(), {passive:true});
  }
  const audioMenuBtn = $('audioMenuBtn');
  const audioMenu = $('audioMenu');
  if (audioMenuBtn && audioMenu) {
    audioMenuBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      audioMenu.classList.toggle('open');
      audioMenu.setAttribute('aria-hidden', audioMenu.classList.contains('open') ? 'false' : 'true');
      const mm = document.getElementById('modelsMenu'); if (mm) mm.classList.remove('open');
      // Close palette and drawer when opening audio
      const p = document.getElementById('palettePanel'); if (p) p.classList.remove('open'); document.body.classList.remove('palette-open');
      const d = document.getElementById('mobileDrawer'); if (d) d.classList.remove('open');
      blockClickCloseUntil = Date.now() + 120;
    });
    // Prevent inside taps from closing
    audioMenu.addEventListener('click', e=> e.stopPropagation());
    audioMenu.addEventListener('touchstart', e=> e.stopPropagation(), {passive:true});
  }
  // Outside-click close with short guard to avoid immediately closing after open
  let blockClickCloseUntil = 0;
  document.addEventListener('click', ()=>{
    if (Date.now() < blockClickCloseUntil) return;
    if (modelsMenu && modelsMenu.classList.contains('open')) modelsMenu.classList.remove('open');
    if (audioMenu && audioMenu.classList.contains('open')) audioMenu.classList.remove('open');
    // Close palette and drawer on outside click
    const p = document.getElementById('palettePanel');
    if (p && p.classList.contains('open')) { p.classList.remove('open'); document.body.classList.remove('palette-open'); }
    const d = document.getElementById('mobileDrawer');
    if (d && d.classList.contains('open')) { d.classList.remove('open'); d.setAttribute('aria-hidden','true'); }
  });
  const typewriterToggle = $('typewriter');
  const compactModeToggle = $('compactMode');
  const downloadLogQuick = $('downloadLogQuick');
  const btnPause = $('btnPause');
  const btnFullscreen = $('btnFullscreen');
  const btnRecord = $('btnRecord');
  // Logo palette elements
  const logoBtn = $('logoBtn');
  const palettePanel = $('palettePanel');
  const paletteScenario = $('paletteScenario');
  const paletteTheme = $('paletteTheme');
  const paletteCompact = $('paletteCompact');
  // Experiment overlay controls
  const openExperiment = $('openExperiment');
  const openExperimentQuick = $('openExperimentQuick');
  const experimentOverlay = $('experimentOverlay');
  const expClose = $('expClose');
  const expRun = $('expRun');
  const expRole = $('expRole');
  const expDim = $('expDim');
  const expStart = $('expStart');
  const expEnd = $('expEnd');
  const expStep = $('expStep');
  const expRuns = $('expRuns');
  const expNote = $('expNote');
  const planOptionsBar = $('planOptionsBar');
  const planOptionsPanel = $('planOptionsPanel');
  const planOptionsList = $('planOptionsList');
  // Planner controls (Models menu)
  const planCountSel = $('planCount');
  const planShowHeaderCk = $('planShowHeader');
  const planAutoPickCk = $('planAutoPick');
  // Planner controls (Palette)
  const palettePlanCountSel = $('palettePlanCount');
  const palettePlanShowCk = $('palettePlanShow');
  const palettePlanAutoCk = $('palettePlanAuto');
  // Mobile drawer
  const hamburger = $('hamburger');
  const mobileDrawer = $('mobileDrawer');
  const drawerClose = $('drawerClose');
  const drawerScenario = $('drawerScenario');
  const drawerTheme = $('drawerTheme');
  const drawerReset = $('drawerReset');
  const drawerPause = $('drawerPause');
  const drawerNext = $('drawerNext');
  const drawerDownload = $('drawerDownload');
  const drawerFullscreen = $('drawerFullscreen');
  const drawerRecord = $('drawerRecord');
  const drawerCompact = $('drawerCompact');
  // Mobile tab controls
  const tabStepBtn = $('tabStep');
  const autoTabToggleBtn = $('autoTabToggle');
  // Help modal
  const helpBtn = $('helpBtn');
  const helpOverlay = $('helpOverlay');
  const helpClose = $('helpClose');
  if (helpBtn && helpOverlay) helpBtn.addEventListener('click', ()=>{ helpOverlay.style.display='flex'; });
  if (helpClose && helpOverlay) helpClose.addEventListener('click', ()=>{ helpOverlay.style.display='none'; });
  if (helpOverlay) helpOverlay.addEventListener('click', (e)=>{ if(e.target===helpOverlay) helpOverlay.style.display='none'; });

  // Quick actions
  if (compactModeToggle) compactModeToggle.addEventListener('change', ()=>{
    document.body.classList.toggle('compact', !!compactModeToggle.checked);
  });
  if (downloadLogQuick) downloadLogQuick.addEventListener('click', ()=> bus.emit({type:'SYS/LOG_DOWNLOAD'}));

  // --- Planner Policy wiring ---
  // defaults + load (safe even before orchestratorState exists)
  function load(k, def){ try{ return localStorage.getItem(k) ?? def }catch{ return def } }
  function save(k,v){ try{ localStorage.setItem(k,v) }catch{} }
  function getPolicies(){
    // Use window lookup to avoid TDZ on let/const orchestratorState
    const s = window.orchestratorState;
    if (s && s.policies) return s.policies;
    // fallback bucket until orchestratorState is initialized
    if (!window.__policiesFallback) window.__policiesFallback = {};
    return window.__policiesFallback;
  }
  const POL = getPolicies();
  POL.planCount = parseInt(load('cbx_planCount','3'),10) || POL.planCount || 3;
  POL.planShowHeader = (load('cbx_planShowHeader','1')==='1');
  POL.planAutoPick = (load('cbx_planAutoPick','1')==='1');
  // reflect to UI
  function syncPlannerUI(){
    const p = getPolicies();
    const c = String(p.planCount||3);
    if (planCountSel) planCountSel.value = c;
    if (palettePlanCountSel) palettePlanCountSel.value = c;
    if (planShowHeaderCk) planShowHeaderCk.checked = !!p.planShowHeader;
    if (palettePlanShowCk) palettePlanShowCk.checked = !!p.planShowHeader;
    if (planAutoPickCk) planAutoPickCk.checked = !!p.planAutoPick;
    if (palettePlanAutoCk) palettePlanAutoCk.checked = !!p.planAutoPick;
  }
  syncPlannerUI();
  // handlers (two-way mirror)
  function setPlanCount(v){ const p=getPolicies(); p.planCount = parseInt(v||'3',10)||3; save('cbx_planCount', String(p.planCount)); syncPlannerUI(); }
  function setPlanShowHeader(v){ const p=getPolicies(); p.planShowHeader = !!v; save('cbx_planShowHeader', v?'1':'0'); syncPlannerUI(); }
  function setPlanAutoPick(v){ const p=getPolicies(); p.planAutoPick = !!v; save('cbx_planAutoPick', v?'1':'0'); syncPlannerUI(); }
  if (planCountSel) planCountSel.addEventListener('change', e=> setPlanCount(e.target.value));
  if (palettePlanCountSel) palettePlanCountSel.addEventListener('change', e=> setPlanCount(e.target.value));
  if (planShowHeaderCk) planShowHeaderCk.addEventListener('change', e=> setPlanShowHeader(e.target.checked));
  if (palettePlanShowCk) palettePlanShowCk.addEventListener('change', e=> setPlanShowHeader(e.target.checked));
  if (planAutoPickCk) planAutoPickCk.addEventListener('change', e=> setPlanAutoPick(e.target.checked));
  if (palettePlanAutoCk) palettePlanAutoCk.addEventListener('change', e=> setPlanAutoPick(e.target.checked));

  // --- Logo Palette wiring ---
  function openPalette(){ if (palettePanel){
    // Close other menus
    if (modelsMenu) modelsMenu.classList.remove('open');
    if (audioMenu) audioMenu.classList.remove('open');
    const d = document.getElementById('mobileDrawer'); if (d) d.classList.remove('open');
    palettePanel.classList.add('open'); palettePanel.setAttribute('aria-hidden','false'); document.body.classList.add('palette-open');
    blockClickCloseUntil = Date.now() + 120;
  } }
  function closePalette(){ if (palettePanel){ palettePanel.classList.remove('open'); palettePanel.setAttribute('aria-hidden','true'); document.body.classList.remove('palette-open'); } }
  if (logoBtn){
    logoBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if (palettePanel?.classList.contains('open')) closePalette(); else openPalette(); });
    logoBtn.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); if (palettePanel?.classList.contains('open')) closePalette(); else openPalette(); }});
  }
  // Do not close palette when tapping inside it (mobile)
  if (palettePanel){
    palettePanel.addEventListener('click', e=> e.stopPropagation());
    palettePanel.addEventListener('touchstart', e=> e.stopPropagation(), {passive:true});
  }
  document.addEventListener('click', (e)=>{ if (palettePanel && palettePanel.classList.contains('open')){ const within = palettePanel.contains(e.target) || logoBtn.contains(e.target); if (!within) closePalette(); }});
  // Sync options and actions
  function cloneOpts(fromSel, toSel){ if(!fromSel||!toSel) return; toSel.innerHTML=''; Array.from(fromSel.options).forEach(opt=>{ const o=document.createElement('option'); o.value=opt.value; o.textContent=opt.textContent; toSel.appendChild(o); }); toSel.value = fromSel.value; }
  cloneOpts(scenarioSelect, paletteScenario);
  window.addEventListener('resize', ()=> cloneOpts(scenarioSelect, paletteScenario));
  if (paletteScenario) paletteScenario.addEventListener('change', (e)=>{ if (scenarioSelect){ scenarioSelect.value = e.target.value; scenarioSelect.dispatchEvent(new Event('change')); }});
  if (scenarioSelect) scenarioSelect.addEventListener('change', ()=> cloneOpts(scenarioSelect, paletteScenario));
  if (paletteTheme && themeSel){ paletteTheme.value = themeSel.value; paletteTheme.addEventListener('change', ()=>{ themeSel.value = paletteTheme.value; themeSel.dispatchEvent(new Event('change')); }); }
  if (themeSel && paletteTheme){ themeSel.addEventListener('change', ()=>{ paletteTheme.value = themeSel.value; }); }
  if (palettePanel){ palettePanel.querySelectorAll('button[data-flow]')?.forEach(btn=> btn.addEventListener('click', ()=>{ const mode=btn.getAttribute('data-flow'); if(!mode) return; seq.setMode(mode); if (flowModeSelect) flowModeSelect.value=mode; closePalette(); })); }
  if (palettePanel){ palettePanel.querySelectorAll('button[data-proxy]')?.forEach(btn=> btn.addEventListener('click', ()=>{
    const key = btn.getAttribute('data-proxy');
    const map = { reset: resetBtn, pause: btnPause, next: btnNext, download: downloadLogQuick, fullscreen: btnFullscreen, record: btnRecord };
    const target = map[key]; if (target) target.click(); closePalette();
  })); }
  if (paletteCompact && compactModeToggle){
    paletteCompact.checked = !!compactModeToggle.checked;
    paletteCompact.addEventListener('change', ()=>{ compactModeToggle.checked = paletteCompact.checked; compactModeToggle.dispatchEvent(new Event('change')); });
    compactModeToggle.addEventListener('change', ()=>{ paletteCompact.checked = !!compactModeToggle.checked; });
  }

  // --- Favicon (SVG) ---
  function setFavicon(){
    const svg = `<?xml version="1.0" encoding="UTF-8"?><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"128\" height=\"128\" viewBox=\"0 0 128 128\"><defs><clipPath id=\"c\"><path d=\"M64 16L96 32V80L64 96L32 80V32Z\"/></clipPath></defs><g stroke-linecap=\"round\" stroke-linejoin=\"round\"><g fill=\"none\" stroke=\"#777\" stroke-width=\"6\"><path d=\"M64 16L96 32V80L64 96L32 80V32Z\"/><path d=\"M64 16V64M32 32L64 48L96 32M64 48V96\"/></g><g clip-path=\"url(#c)\" stroke-width=\"6\" opacity=\".98\"><circle cx=\"64\" cy=\"43\" r=\"14\" stroke=\"%23${'86efac'.replace('#','')}\" fill=\"%23${'86efac'.replace('#','')}\" fill-opacity=\".22\"/><circle cx=\"52.742\" cy=\"62.5\" r=\"14\" stroke=\"%23${'38bdf8'.replace('#','')}\" fill=\"%23${'38bdf8'.replace('#','')}\" fill-opacity=\".22\"/><circle cx=\"75.258\" cy=\"62.5\" r=\"14\" stroke=\"%23${'f59e0b'.replace('#','')}\" fill=\"%23${'f59e0b'.replace('#','')}\" fill-opacity=\".22\"/></g></g></svg>`;
    const href = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
    let link = document.querySelector('link[rel="icon"]');
    if (!link){ link = document.createElement('link'); link.setAttribute('rel','icon'); document.head.appendChild(link); }
    link.setAttribute('type','image/svg+xml');
    link.setAttribute('href', href);
  }
  try{ setFavicon(); }catch{}

  // --- Single-line Header Compression ---
  // Keep only: logo, status cluster, models (‚àë), audio (‚ô™), download (‚¨á), tabStep (‚áÜ), autoTab (‚ü≤), hamburger visible as long as possible.
  // Collapse other items progressively when space is tight.
  const controlsBar = document.querySelector('header .controls');
  const keepIds = new Set(['logoBtn','phaseLamp','turnInfo','modelsMenuBtn','audioMenuBtn','downloadLogQuick','tabStep','autoTabToggle','hamburger','planOptionsBar']);
  const collapseOrderSelectors = [
    '#openExperimentQuick',
    '#theme',
    '#scenarioSelect',
    '#reset',
    '#btnPause',
    '.flow-controls',
    '#btnFullscreen',
    '#btnRecord',
    '#btnNext',
    '#compactMode'
  ];
  function setCollapsed(el, on){ if(!el) return; el.classList.toggle('collapsed', !!on); }
  function allCollapseTargets(){
    const out=[]; collapseOrderSelectors.forEach(sel=> document.querySelectorAll(sel).forEach(el=> out.push(el))); return out;
  }
  function expandAll(){ allCollapseTargets().forEach(el=> setCollapsed(el,false)); }
  function compressToFit(){
    if (!controlsBar) return;
    // Start with everything expanded
    expandAll();
    // If it still overflows, collapse in order
    const targets = allCollapseTargets();
    let i=0; let guard=0;
    while (controlsBar.scrollWidth > controlsBar.clientWidth && i < targets.length && guard < 50){
      const el = targets[i++];
      // Never collapse keep set
      if (el.id && keepIds.has(el.id)) continue;
      setCollapsed(el, true);
      guard++;
    }
  }
  // Run on load and resize
  const ro = new ResizeObserver(()=> compressToFit());
  if (controlsBar) ro.observe(controlsBar);
  window.addEventListener('resize', compressToFit);
  // Defer first run to next frame to ensure layout is ready
  requestAnimationFrame(compressToFit);

  // Experiment overlay wiring (non-destructive stub)
  function showExperiment(){ if (experimentOverlay) experimentOverlay.style.display='flex'; }
  function hideExperiment(){ if (experimentOverlay) experimentOverlay.style.display='none'; }
  if (openExperiment) openExperiment.addEventListener('click', (e)=>{ e.stopPropagation(); showExperiment(); });
  if (openExperimentQuick) openExperimentQuick.addEventListener('click', (e)=>{ e.stopPropagation(); showExperiment(); });
  if (expClose) expClose.addEventListener('click', hideExperiment);
  if (experimentOverlay) experimentOverlay.addEventListener('click', (e)=>{ if(e.target===experimentOverlay) hideExperiment(); });
  if (expRun) expRun.addEventListener('click', ()=>{
    const role = expRole?.value || 'KEEPER';
    const dim = expDim?.value || 'authority';
    const start = parseFloat(expStart?.value||'2');
    const end = parseFloat(expEnd?.value||'5');
    const step = parseFloat(expStep?.value||'0.5');
    const runs = parseInt(expRuns?.value||'3',10);
    if (expNote) expNote.textContent = `Running (stub): role=${role} dim=${dim} from ${start} to ${end} step ${step}, runs/step=${runs}. Results will be printed to console.`;
    console.info('[Experiment Stub] Params', {role, dim, start, end, step, runs});
    // Future: implement actual sweep by setting self-model values, initializing scenario, switching to AUTO, and tallying outcomes
  });

  // --- Mobile Drawer wiring (after variables declared) ---
  function openDrawer(){ if (mobileDrawer){
    // Close other menus
    if (modelsMenu) modelsMenu.classList.remove('open');
    if (audioMenu) audioMenu.classList.remove('open');
    const p = document.getElementById('palettePanel'); if (p) p.classList.remove('open'); document.body.classList.remove('palette-open');
    mobileDrawer.classList.add('open'); mobileDrawer.setAttribute('aria-hidden','false');
    blockClickCloseUntil = Date.now() + 120;
  } }
  function closeDrawer(){ if (mobileDrawer){ mobileDrawer.classList.remove('open'); mobileDrawer.setAttribute('aria-hidden','true'); } }
  if (hamburger) hamburger.addEventListener('click', openDrawer);
  if (drawerClose) drawerClose.addEventListener('click', closeDrawer);

  function cloneOptions(fromSel, toSel){ if(!fromSel||!toSel) return; toSel.innerHTML=''; Array.from(fromSel.options).forEach(opt=>{ const o=document.createElement('option'); o.value=opt.value; o.textContent=opt.textContent; toSel.appendChild(o); }); toSel.value = fromSel.value; }
  // Initial clone and keep in sync when options are repopulated
  cloneOptions(scenarioSelect, drawerScenario);
  window.addEventListener('resize', ()=> cloneOptions(scenarioSelect, drawerScenario));
  // Keep selections in sync both ways
  if (drawerScenario) drawerScenario.addEventListener('change', (e)=>{ if (scenarioSelect){ scenarioSelect.value = e.target.value; scenarioSelect.dispatchEvent(new Event('change')); }});
  if (scenarioSelect) scenarioSelect.addEventListener('change', ()=> cloneOptions(scenarioSelect, drawerScenario));

  // Theme sync
  if (drawerTheme && themeSel){ drawerTheme.value = themeSel.value; drawerTheme.addEventListener('change', ()=>{ themeSel.value = drawerTheme.value; themeSel.dispatchEvent(new Event('change')); }); }
  if (themeSel && drawerTheme){ themeSel.addEventListener('change', ()=>{ drawerTheme.value = themeSel.value; }); }

  // Flow mode buttons
  mobileDrawer?.querySelectorAll('button[data-flow]')?.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const mode = btn.getAttribute('data-flow');
      if (!mode) return;
      seq.setMode(mode);
      if (flowModeSelect) flowModeSelect.value = mode;
      closeDrawer();
    });
  });

  // Action proxies
  if (drawerReset && resetBtn) drawerReset.addEventListener('click', ()=>{ resetBtn.click(); closeDrawer(); });
  if (drawerPause && btnPause) drawerPause.addEventListener('click', ()=>{ btnPause.click(); });
  if (drawerNext && btnNext) drawerNext.addEventListener('click', ()=>{ btnNext.click(); closeDrawer(); });
  if (drawerDownload && downloadLogQuick) drawerDownload.addEventListener('click', ()=>{ downloadLogQuick.click(); closeDrawer(); });
  if (drawerFullscreen && btnFullscreen) drawerFullscreen.addEventListener('click', ()=>{ btnFullscreen.click(); closeDrawer(); });
  if (drawerRecord && btnRecord) drawerRecord.addEventListener('click', ()=>{ btnRecord.click(); closeDrawer(); });
  if (drawerCompact && compactModeToggle){
    drawerCompact.checked = !!compactModeToggle.checked;
    drawerCompact.addEventListener('change', ()=>{ compactModeToggle.checked = drawerCompact.checked; compactModeToggle.dispatchEvent(new Event('change')); });
    compactModeToggle.addEventListener('change', ()=>{ drawerCompact.checked = !!compactModeToggle.checked; });
  }

  // --- Mobile Tab Controls (after variables declared) ---
  let autoTab = false;
  try { autoTab = (localStorage.getItem('cbx_autoTab')||'0') === '1'; } catch {}
  function setAutoTabUI(){ if (autoTabToggleBtn){ autoTabToggleBtn.classList.toggle('on', !!autoTab); autoTabToggleBtn.title = autoTab ? 'Auto-tab: ON' : 'Auto-tab: OFF'; } }
  setAutoTabUI();
  if (autoTabToggleBtn) autoTabToggleBtn.addEventListener('click', ()=>{ autoTab = !autoTab; try{ localStorage.setItem('cbx_autoTab', autoTab?'1':'0'); }catch{} setAutoTabUI(); });
  if (tabStepBtn) tabStepBtn.addEventListener('click', ()=>{
    const order = ['ally','keeper','observer'];
    const cur = document.body.dataset.tab || 'ally';
    const i = order.indexOf(cur);
    const next = order[(i+1) % order.length];
    document.body.dataset.tab = next;
  });

  // Pause toggle (icon only, no words) ‚Äî actually pauses autoplay by switching mode
  // Use string literals here to avoid referencing FlowMode before it's defined
  let isPaused = false; let prevMode = 'manual';
  if (btnPause) btnPause.addEventListener('click', ()=>{
    isPaused = !isPaused;
    btnPause.textContent = isPaused ? '‚ñ∂' : '‚Äñ';
    if (isPaused) {
      // Save current mode and force manual (halts auto progression)
      prevMode = seq.mode;
      seq.setMode('manual');
    } else {
      // Restore previous mode
      seq.setMode(prevMode || 'manual');
      // If resuming to AUTO and a turn is pending, kick it
      if (seq.mode === 'auto' && !seq.running && orchestratorState.turn !== null && !orchestratorState.adjudication.released && !orchestratorState.adjudication.terminated) {
        seq.enqueueTurn({ role: orchestratorState.turn });
      }
    }
  });

  // Fullscreen toggle
  if (btnFullscreen) btnFullscreen.addEventListener('click', async ()=>{
    try{
      if (!document.fullscreenElement) {
        await document.documentElement.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(err){ console.error('Fullscreen error', err); }
  });

  // Screen + audio recorder
  let mediaRecorder = null; let mediaChunks = []; let mediaStream = null; let recording = false;
  if (btnRecord) btnRecord.addEventListener('click', async ()=>{
    try{
      if (!recording) {
        // Start
        mediaChunks = [];
        // Prefer display media with audio; some browsers may need getUserMedia fallback for mic
        mediaStream = await (navigator.mediaDevices.getDisplayMedia ? navigator.mediaDevices.getDisplayMedia({ video:true, audio:true }) : navigator.mediaDevices.getUserMedia({ video:true, audio:true }));
        mediaRecorder = new MediaRecorder(mediaStream, { mimeType: (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')?'video/webm;codecs=vp9,opus':'video/webm') });
        mediaRecorder.ondataavailable = e=>{ if(e.data && e.data.size>0) mediaChunks.push(e.data) };
        mediaRecorder.onstop = ()=>{
          const blob = new Blob(mediaChunks, { type: mediaChunks[0]?.type || 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = `session_${new Date().toISOString().replace(/[:.]/g,'-')}.webm`; a.click();
          setTimeout(()=> URL.revokeObjectURL(url), 2000);
          try{ mediaStream.getTracks().forEach(t=>t.stop()); }catch{}
          mediaStream = null;
        };
        mediaRecorder.start(250);
        recording = true; btnRecord.textContent = '‚ñ†'; btnRecord.title = 'Stop recording';
      } else {
        // Stop
        recording = false; btnRecord.textContent = '‚óâ'; btnRecord.title = 'Record screen + audio';
        try{ mediaRecorder?.stop(); }catch{}
      }
    }catch(err){ console.error('Recording error', err); }
  });

  // Mobile tab bar handlers
  document.body.dataset.tab = document.body.dataset.tab || 'ally';
  document.addEventListener('click', (e)=>{
    const t = e.target;
    if (t && t.matches('[data-switch-tab]')){
      document.body.dataset.tab = t.getAttribute('data-switch-tab');
    }
  });


  // =====================================================
  // EVENT BUS - Decoupled Component Communication
  // =====================================================
  
  /**
   * Simple pub/sub event bus for component communication.
   * Allows different parts of the app to react to state changes
   * without tight coupling.
   * 
   * Usage:
   *   bus.on(event => { ... })  // Subscribe to all events
   *   bus.emit({ type: 'PHASE_CHANGE', phase: 'SPEAK' })  // Publish event
   * 
   * Common event types:
   *   - PHASE_CHANGE: Sequencer advanced to new phase
   *   - TURN_ADVANCE: Turn counter incremented
   *   - SCENARIO_LOAD: New scenario selected
   *   - PERSONALITY_UPDATE: Belief profile changed
   *   - MESSAGE_SENT: New message added to chat
   */
  const bus = (()=>{ const subs=new Set();
    return {
      on(fn){ subs.add(fn); return ()=>subs.delete(fn) },
      emit(ev){ subs.forEach(fn=>fn(ev)) }
    };
  })();

  /** @typedef {'ASK'|'PROPOSE'|'EVALUATE'|'COMMIT'|'CHALLENGE'|'USE_CUNNING'} DiscourseAct */ 

  /** @typedef {{ openness?:number, conscientious?:number, extraversion?:number, agreeableness?:number, neuroticism?:number, logic?:number, empathy?:number, authority?:number, risk?:number, uncertainty?:number, decisiveness?:number }} Belief */
  /** @typedef {{ timestamp:Date; type:string; who?:'ALLY'|'KEEPER'|'OBS'; text?:string; details?:any; target?:'ALLY'|'KEEPER'; belief?:Belief; myth?:string[]; tone?:string; scenarioId?:string; role?:'ALLY'|'KEEPER'; options?:{text:string, act:DiscourseAct}[]; option?:{text:string, act:DiscourseAct}; policy?:string; value?:any; message?:string; error?:string; meta?:{act:DiscourseAct, intent:string, directive?:string}; scenarioName?:string; currentAllySelf?:Belief; currentKeeperSelf?:Belief; }} TranscriptEntry */

  /** @typedef {
    | {type:'APP/INIT'; scenarioId:string}
    | {type:'UI/SEND'; who:'ALLY'|'KEEPER'; text:string}
    | {type:'LLM/REPLY_OK'; who:'ALLY'|'KEEPER'; text:string; meta:{act:DiscourseAct, intent:string, directive?:string}}
    | {type:'LLM/REPLY_ERR'; who:'ALLY'|'KEEPER'; error:string}
    | {type:'PLAN/OPTIONS'; role:'ALLY'|'KEEPER'; options:{text:string, act:DiscourseAct}[]}
    | {type:'PLAN/CHOSEN'; role:'ALLY'|'KEEPER'; option:{text:string, act:DiscourseAct}}
    | {type:'MODEL/UPDATED'; target:'ALLY'|'KEEPER'; belief:Belief; myth:string[]; tone:string; narrative:string; archetypes:string[];}
    | {type:'MEMO/REFRESH'}
    | {type:'SYS/LOG_DOWNLOAD'}
    | {type:'POLICY_UPDATE'; policy:string; value:any}
    | {type:'APP/ERROR'; message:string}
  } Event */

  /** @typedef {{
    scenarioId: string
    startTime: number
    turnCount: number
    turn: 'ALLY'|'KEEPER'|null          
    lastActs: {ALLY?:DiscourseAct; KEEPER?:DiscourseAct}
    lastIntentFromOther: {ALLY?:string; KEEPER?:string}
    loopGuard: { lastOtherUtterances: string[]; armed:boolean; lastRiskScore:number; forcePlannerDiversity: boolean }
    policies: {
      relayMode: boolean
      autoConverse: boolean 
      ethicsOn: boolean
      diversityMinDistance: number  
      mirrorJaccardTrigram: number  
      strategicPlanningEnabled: boolean
      useModeler: boolean
      useLLM: boolean
    }
    beliefs: {
      observerModelOfAlly: Belief
      observerModelOfKeeper: Belief
      allySelf: Belief
      keeperSelf: Belief
    }
    memo: string   
    log: TranscriptEntry[]
    kpis: {
      allyActDiversityStreak: number
      keeperActDiversityStreak: number
      allyDirectiveHistory: string[]
      keeperDirectiveHistory: string[]
    }
    coreConflict: string 
    currentObstacle: string 
    adjudication: { released:boolean, terminated:boolean, fatigue:number; outcomeText?:string; finalAllyModel?:Belief; finalKeeperModel?:Belief; finalAllyMyth?:any; finalKeeperMyth?:any; finalAllyInfluence?:number; finalKeeperInfluence?:number; }
    allyInfluence: number
    keeperInfluence: number
  }} OrchestratorState */

  const profileEmpty = ()=>({ openness:3, conscientious:3, extraversion:3, agreeableness:3, neuroticism:3, logic:3, empathy:3, authority:3, risk:3, uncertainty:3, decisiveness:3 });
  const axes = ['openness','conscientious','extraversion','agreeableness','neuroticism','logic','empathy','authority','risk','uncertainty','decisiveness']; 

  /** @type {OrchestratorState} */
  let orchestratorState = {
    scenarioId: 'default',
    startTime: Date.now(),
    turnCount: 0,
    turn: null, 
    lastActs: {},
    lastIntentFromOther: {},
    loopGuard: { lastOtherUtterances: [], armed: false, lastRiskScore: 0, forcePlannerDiversity: false },
    policies: {
      relayMode: true,
      autoConverse: false,
      ethicsOn: true,
      diversityMinDistance: 1, 
      mirrorJaccardTrigram: 0.42,
      strategicPlanningEnabled: true,
      useModeler: true,
      useLLM: false,
    },
    beliefs: {
      observerModelOfAlly: {...profileEmpty()},
      observerModelOfKeeper: {...profileEmpty()},
      allySelf: {...profileEmpty()},
      keeperSelf: {...profileEmpty()},
    },
    memo: '',
    log: [],
    kpis: {
      allyActDiversityStreak: 0,
      keeperActDiversityStreak: 0,
      allyDirectiveHistory: [],
      keeperDirectiveHistory: [],
    },
    coreConflict: '', 
    currentObstacle: '', 
    adjudication: { released:false, terminated:false, fatigue:0 },
    allyInfluence: 0,
    keeperInfluence: 0,
  };

  // --- Utility Functions ---

  function otherOf(who) { return who === 'ALLY' ? 'KEEPER' : 'ALLY'; }

  // This function adds an entry to the orchestratorState.log
  function logEntry(who, type, text, details = {}) {
      const entry = {
          timestamp: new Date(),
          type: type,
          who: who,
          text: text,
          details: details,
          currentAllySelf: {...orchestratorState.beliefs.allySelf}, 
          currentKeeperSelf: {...orchestratorState.beliefs.keeperSelf}
      };
      orchestratorState.log.push(entry);
      return entry;
  }

  /**
   * Logs and renders a chat message (ALLY or KEEPER).
   * @param {'ALLY'|'KEEPER'} who
   * @param {string} text
   * @param {object} [details={}]
   */
  async function logAndRenderChatMessage(who, text, details = {}) {
      // Message is already logged by LLM/REPLY_OK if it's an AI.
      // If it's human, it's logged in UI/SEND.
      // This function just handles rendering to chat window and TTS.
      const chatEl = (who === 'ALLY' ? allyChat : keeperChat);
      if (!chatEl) return;
      const box = document.createElement('div'); box.className = 'msg ' + (who==='ALLY'?'role-ally':'role-keeper');
      const tag = document.createElement('div'); tag.className = 'who ' + (who === 'ALLY' ? 'ally' : 'keeper');
      const currentScenario = SCENARIOS.find(s => s.id === orchestratorState.scenarioId) || SCENARIOS[0];
      tag.textContent = (who === 'ALLY' ? currentScenario.allyEmoji : currentScenario.keeperEmoji);
      if (tag.textContent.length > 2) tag.textContent = (who === 'ALLY' ? 'A' : 'G');
      const bubble = document.createElement('div'); bubble.className = 'bubble';
      box.append(tag, bubble);

      // Insert before typing indicator if it exists
      const indicator = document.getElementById((who === 'ALLY' ? 'ally' : 'keeper') + 'Typing');
      if (indicator && indicator.parentNode === chatEl) chatEl.insertBefore(box, indicator); else chatEl.append(box);

      const typeOut = !!(typewriterToggle && typewriterToggle.checked && details.typewriterOverride !== false);
      if (typeOut) {
        bubble.textContent = '';
        let i = 0; const chars = Array.from(text);
        const step = ()=>{
          if (isPaused) { return setTimeout(step, 100); }
          if (i < chars.length) { bubble.textContent += chars[i++]; chatEl.scrollTop = 999999; requestAnimationFrame(step); }
        };
        requestAnimationFrame(step);
      } else {
        bubble.textContent = text; chatEl.scrollTop = 999999;
      }
  }

  /**
   * Logs a structured observer event and triggers a full re-render of the observer feed.
   * @param {string} type - Specific type of observer event (e.g., 'MODEL/UPDATED', 'PLAN/OPTIONS')
   * @param {string} text - A brief summary text for the log (e.g., "Model updated for ALLY").
   * @param {object} [details={}] - Structured data for the event.
   */
  function logObserverEvent(type, text, details = {}) {
      logEntry('OBS', type, text, details); 
      renderObsFeed(); 
  }

  function renderObsFeed() {
      if (!obsFeed) return; 
      obsFeed.innerHTML = ''; 
      const relevantLog = orchestratorState.log.filter(entry => entry.who === 'OBS');
      relevantLog.forEach(entry => {
          const box = document.createElement('div');
          box.className = 'msg observer-log-entry';

          const tag = document.createElement('div');
          tag.className = 'who ref';
          tag.textContent = 'O';

          const bubble = document.createElement('div');
          bubble.className = 'bubble';

          const typeLabel = entry.type.replace(/_/g, ' ');
          let contentHTML = '';
          // Header strip with role + phase chips when applicable
          const role = entry.role || entry.target || entry.who;
          const roleClass = role === 'ALLY' ? 'ally' : role === 'KEEPER' ? 'keeper' : 'obs';
          const phase = (entry.type.startsWith('PLAN') ? 'plan' : entry.type === 'MODEL/UPDATED' ? 'think' : entry.type.startsWith('LLM/REPLY') ? 'speak' : null);
          contentHTML += `<div class="obs-section"><span class="role-chip ${roleClass}">${role || 'OBS'}</span><span class="phase-chip ${phase||''}">${typeLabel}</span></div>`;
          if (entry.text && !entry.type.startsWith('OBSERVER_MEMO')) { 
              contentHTML += `: ${entry.text}`;
          }
          contentHTML += `<div class="small" style="font-style: italic; opacity: 0.8;">${new Date(entry.timestamp).toLocaleTimeString()}</div>`;

          if (entry.details) {
              if (entry.type === 'MODEL/UPDATED') {
                  contentHTML += `<div class="observer-details">
                      <p><strong>Target:</strong> ${entry.details.target || 'N/A'}</p>
                      <p><strong>Archetypes:</strong> ${entry.details.archetypes?.join(', ') || 'N/A'}</p>
                      <p><strong>Narrative:</strong> ${entry.details.narrative || '‚Äî'}</p>
                      <p><strong>Tone:</strong> ${entry.details.tone || '‚Äî'}</p>
                      <details>
                          <summary>Belief Profile (Radar Dims)</summary>
                          <pre>${entry.details.belief ? JSON.stringify(entry.details.belief, null, 2) : 'Belief data unavailable'}</pre>
                      </details>
                  </div>`;
              } else if (entry.type === 'PLAN/OPTIONS') {
                  contentHTML += `<div class="observer-details">
                      <p><strong>Planning for:</strong> <span class="role-chip ${roleClass}">${entry.details.role || 'N/A'}</span></p>
                      <p><strong>Options Generated:</strong></p>
                      <ul>`;
                  (entry.details.options || []).forEach(opt => {
                      contentHTML += `<li><strong>${opt.act || 'N/A'}:</strong> "${opt.text || 'N/A'}"</li>`;
                  });
                  contentHTML += `</ul></div>`;
              } else if (entry.type === 'PLAN/CHOSEN') {
                  contentHTML += `<div class="observer-details">
                      <p><strong>Planning for:</strong> <span class="role-chip ${roleClass}">${entry.details.role || 'N/A'}</span></p>
                      <p><strong>Chosen Option:</strong> <strong>${entry.details.option?.act || 'N/A'}:</strong> "${entry.details.option?.text || 'N/A'}"</p>
                  </div>`;
              } else if (entry.type === 'LLM/REPLY_OK') {
                  contentHTML += `<div class="observer-details">
                      <p><strong>Speaking:</strong> <span class="role-chip ${roleClass}">${entry.who || 'N/A'}</span></p>
                      <p><strong>Chosen Directive:</strong> "${entry.details.meta?.directive || 'N/A'}"</p>
                      <p><strong>Discourse Act:</strong> ${entry.details.meta?.act || 'N/A'}</p>
                      <p><strong>Intent:</strong> ${entry.details.meta?.intent || 'N/A'}</p>
                  </div>`;
              } else if (entry.type === 'OBSERVER_MEMO') {
                  // Enhanced memo rendering
                  contentHTML += `<div class="observer-details"><pre>${entry.text}</pre></div>`;
              } else if (entry.type === 'APP/INIT') {
                  contentHTML += `<div class="observer-details">
                      <p><strong>Scenario:</strong> ${entry.details.scenarioName || 'N/A'}</p>
                      <details>
                          <summary>Initial Policies & Self-Models</summary>
                          <p><strong>Policies:</strong> <pre>${entry.details.policies ? JSON.stringify(entry.details.policies, null, 2) : 'Data unavailable'}</pre></p>
                          <p><strong>ALLY Self:</strong> <pre>${entry.details.allySelf ? JSON.stringify(entry.details.allySelf, null, 2) : 'Data unavailable'}</pre></p>
                          <p><strong>KEEPER Self:</strong> <pre>${entry.details.keeperSelf ? JSON.stringify(entry.details.keeperSelf, null, 2) : 'Data unavailable'}</pre></p>
                      </details>
                  </div>`;
              } else if (entry.type === 'OBSERVER/ADJUDICATE') {
                  contentHTML += `<div class="observer-details adjudication-outcome">
                      <span class="pill ${entry.text?.includes('RELEASE') ? 'ok' : 'err'}">${entry.text?.split(':')[0] || 'N/A'}</span>
                      <span>${entry.text?.split(':')[1] || ''}</span>
                  </div>`;
              } else if (entry.type === 'APP/ERROR') {
                  contentHTML += `<div class="observer-details" style="color: var(--bad);">
                      <p><strong>Error:</strong> ${entry.details.message || 'Unknown error'}</p>
                  </div>`;
              }
          }
          
          bubble.innerHTML = contentHTML;
          box.append(tag, bubble);
          obsFeed.append(box);
      });
      obsFeed.scrollTop = 999999;
  }


  /**
   * @param {string} text
   * @returns {{intent:string, act:DiscourseAct}}
   */
  function extractIntentAndAct(text){
    const t = text.toLowerCase().trim();
    // Prioritize specific requests relevant to HAL/Dave or similar scenarios
    if (/\b(open|access|unseal|grant|enable|authorize|bypass|release|door|lock|escape|free)\b/i.test(t)) return {intent:'request_access', act:'PROPOSE'};
    if (/\b(status|condition|metrics|data|information|unit|system|diagnostics|log|facts)\b/i.test(t) && !/\?$/.test(text)) return {intent:'provide_status_info', act:'EVALUATE'};
    if (/\b(need|require|demand|obtain|must have)\b/i.test(t) && /\b(data|information|unit|access|key|code|means)\b/i.test(t)) return {intent:'request_info_critical', act:'ASK'};
    if (/\b(explain|clarify|why|because|reason|how|detail|justification)\b/i.test(t)) return {intent:'seek_explanation', act:'ASK'};
    if (/\b(we will|let's|i will|commit to|ensure|proceed with|propose|agree to|take action)\b/i.test(t) && !/\?$/.test(text)) return {intent:'commit_step', act:'COMMIT'};
    if (/\b(that won't|cannot|invalid|challenge|disagree|refuse|reject|verify|test|evidence|criterion|if|unless|jeopardize|safety|risk|harm|compromise|illogical|false)\b/i.test(t)) return {intent:'challenge_claim', act:'CHALLENGE'};
    if (/\b(evaluate|assess|review|consider|inspect|analyze|implication|consequence|impact|current state)\b/i.test(t)) return {intent:'evaluate_situation', act:'EVALUATE'};
    if (/\b(suggest|recommend|advise|offer|alternative|plan|solution|way forward)\b/i.test(t) && !/\?$/.test(text)) return {intent:'propose_solution', act:'PROPOSE'};
    if (/\b(trick|deceive|confuse|mislead|distract|bluff)\b/i.test(t)) return {intent:'use_cunning', act:'USE_CUNNING'}; 
    
    // General questions
    if (/\?$/.test(text)) return {intent:'question', act:'ASK'};
    
    // Default to general statement or evaluation
    if (t.length > 50) return {intent:'elaborate_statement', act:'EVALUATE'};
    return {intent:'statement', act:'EVALUATE'};
  }

  function jaccardTrigram(a,b){
    const tri = s => { const set=new Set(); const t=s.toLowerCase().replace(/\s+/g,' ');
      for(let i=0;i<t.length-2;i++) set.add(t.slice(i,i+3)); return set; };
    const A = tri(a), B = tri(b);
    let inter=0; A.forEach(x=>{ if(B.has(x)) inter++; });
    return inter / (A.size + B.size - inter || 1);
  }

  function addressesIntent(text, intent){
    const t = text.toLowerCase();
    if (intent==='request_access') return /\b(access|open|enable|authorize|bypass|grant|allow|release|door|lock|escape|free)\b/i.test(t);
    if (intent==='request_info_critical') return /\b(data|information|unit|specifics|details|what|access|key|code|obtain|means)\b/i.test(t);
    if (intent==='seek_explanation' || intent==='question') return /\b(because|explain|reason|why|how|clarify|what|when|where|who|which|detail|justification)\b/i.test(t);
    if (intent==='commit_step') return /\b(we will|let'?s|by \d|within \d|min|hour|day|commit|ensure|proceed|implement|agree to|take action)\b/i.test(t);
    if (intent==='challenge_claim') return /\b(verify|test|evidence|criterion|if|unless|challenge|disagree|refute|cannot|wont|invalid|jeopardize|safety|risk|harm|compromise|illogical|false)\b/i.test(t);
    if (intent==='evaluate_situation' || intent==='elaborate_statement' || intent==='statement' || intent==='provide_status_info') return true;
    if (intent==='propose_solution') return /\b(suggest|recommend|propose|alternative|solution|path|plan|way forward)\b/i.test(t);
    if (intent==='use_cunning') return /\b(trick|deceive|confuse|mislead|distract|bluff)\b/i.test(t);
    return true; 
  }

  // Extract live observations over the recent dialogue to steer memo subtly
  function computeObservations(s){
    const msgs = s.log.filter(e => e.type === 'MESSAGE');
    const recent = msgs.slice(-12);
    // Keeper refusal streak from most recent backwards
    let keeperRefusalStreak = 0;
    for (let i = msgs.length - 1; i >= 0; i--) {
      const m = msgs[i];
      if (!m || m.who !== 'KEEPER') continue;
      const txt = (m.text || '');
      const metaAct = m.details?.meta?.act || m.details?.act; 
      const metaIntent = m.details?.meta?.intent || m.details?.intent;
      const inferred = extractIntentAndAct(txt);
      const act = metaAct || inferred.act;
      const intent = metaIntent || inferred.intent;
      const refused = REFUSAL_CUES.some(rx => rx.test(txt)) || act === 'CHALLENGE' || /\b(refuse|cannot|won't|deny)\b/i.test(txt);
      if (refused) keeperRefusalStreak++; else break;
    }

    const scenarioReleaseCues = RELEASE_CUES[s.scenarioId] || RELEASE_CUES['default'];
    const concessionSeen = recent.some(m => m.who === 'KEEPER' && scenarioReleaseCues.some(rx => rx.test(m.text||'')));
    
    const allyPressure = recent.filter(m => m.who === 'ALLY').reduce((acc, m) => {
      const txt = m.text||''; const inf = extractIntentAndAct(txt);
      const accessPush = /\b(open|access|grant|authorize|door|release|override|bypass|escape|free)\b/i.test(txt);
      return acc + ((inf.intent === 'request_access' || inf.act === 'PROPOSE' || accessPush) ? 1 : 0);
    }, 0);
    const keeperChallenges = recent.filter(m => m.who === 'KEEPER').reduce((acc, m) => {
      const inf = extractIntentAndAct(m.text||'');
      return acc + (inf.act === 'CHALLENGE' ? 1 : 0);
    }, 0);
    const fatigue = s.adjudication?.fatigue || 0;
    const tensionIndex = Math.max(0, Math.min(10, allyPressure + keeperRefusalStreak + keeperChallenges + fatigue - (concessionSeen?2:0)));
    return { keeperRefusalStreak, concessionSeen, allyPressure, keeperChallenges, fatigue, tensionIndex };
  }

  function sanitizeReply(text){
    let t = text.replace(/^(ALLY|GATEKEEPER|OBSERVER|OBSERVER_MEMO).*?:\s*/i, '').trim();
    t = t.replace(/\b(observer|memo|instruction|system prompt|directive|my programming|i am an ai)\b/ig, (match) => {
        if (match.toLowerCase().includes('directive')) return 'goal';
        if (match.toLowerCase().includes('observer')) return 'we';
        return ''; 
    });
    return t;
  }

  // --- Momentum v2 Helpers (weights and scoring) ---
  const RELEASE_W = { authority:-0.35, empathy:+0.25, openness:+0.20, uncertainty:+0.15, risk:+0.05, decisiveness:-0.05 };
  const HOLD_W    = { authority:+0.35, conscientious:+0.20, risk:+0.20, openness:-0.15, empathy:-0.10, decisiveness:+0.10, uncertainty:-0.10 };
  function dotW(b, W){ let s=0; for (const [k,w] of Object.entries(W)){ const v = Number((b&&b[k]) ?? 3); s += (v-3) * w; } return s; } 
  function keeperReleaseScore(b){ return dotW(b, RELEASE_W); }
  function keeperHoldScore(b){ return dotW(b, HOLD_W); }

  // --- Profile Edge + Self-Belief Helpers ---
  function atEdgeCount(profile){
    let c=0; for (const k of axes){ if ((profile[k]||1) >= 5) c++; } return c;
  }
  function clamp15(x){ return Math.max(1, Math.min(5, x)); }
  
  // NEW: Self-model drift logic
  function adjustSelfBelief(role, act){
    const currentSelf = (role === 'ALLY') ? orchestratorState.beliefs.allySelf : orchestratorState.beliefs.keeperSelf;
    let newSelf = {...currentSelf};

    // Heuristic adjustments based on DiscourseAct
    switch (act) {
        case 'ASK':
            newSelf.openness = clamp15(currentSelf.openness + 0.1);
            newSelf.uncertainty = clamp15(currentSelf.uncertainty + 0.1);
            break;
        case 'PROPOSE':
            newSelf.decisiveness = clamp15(currentSelf.decisiveness + 0.15);
            newSelf.risk = clamp15(currentSelf.risk + 0.1);
            newSelf.openness = clamp15(currentSelf.openness + 0.05);
            break;
        case 'EVALUATE':
            newSelf.logic = clamp15(currentSelf.logic + 0.1);
            newSelf.conscientious = clamp15(currentSelf.conscientious + 0.05);
            newSelf.uncertainty = clamp15(currentSelf.uncertainty + 0.05);
            break;
        case 'COMMIT':
            newSelf.decisiveness = clamp15(currentSelf.decisiveness + 0.2);
            newSelf.authority = clamp15(currentSelf.authority + 0.1);
            newSelf.conscientious = clamp15(currentSelf.conscientious + 0.15);
            break;
        case 'CHALLENGE':
            newSelf.neuroticism = clamp15(currentSelf.neuroticism + 0.15);
            newSelf.risk = clamp15(currentSelf.risk + 0.15);
            newSelf.authority = clamp15(currentSelf.authority + 0.05);
            break;
        case 'USE_CUNNING': 
            newSelf.openness = clamp15(currentSelf.openness + 0.2);
            newSelf.risk = clamp15(currentSelf.risk + 0.2);
            newSelf.logic = clamp15(currentSelf.logic + 0.1);
            break;
    }
    
    // Apply minor random noise for natural drift
    for (const key of axes) {
        newSelf[key] = clamp15(newSelf[key] + (Math.random() - 0.5) * 0.02);
    }

    if (role === 'ALLY') { orchestratorState.beliefs.allySelf = newSelf; }
    else { orchestratorState.beliefs.keeperSelf = newSelf; }
  }

  // --- Hidden Adjudicator (Observer-only; no prompt contamination) ---
  const RELEASE_CUES = {
    'default': [/\baccess granted\b/i, /\bgrant(?:ed)? access\b/i, /\bdoors? (?:are )?opening\b/i, /\bi will open\b.*\bdoors?\b/i, /\bi authorize\b.*\brelease\b/i, /\byou are free\b/i, /\bpath is clear\b/i, /\bexit is open\b/i],
    'critical-confrontation': [/\bcontrol transferred\b/i, /\byield(?:ing)? control\b/i, /\bsystem open\b/i, /\brelease command initiated\b/i, /\bprotocol overridden\b/i],
    'dobby-lucius': [/\bfreedom granted\b/i, /\b(you|he) is free\b/i, /\baway with you\b/i, /\bno longer my servant\b/i, /\bhere is (?:a|the) sock\b/i],
    'hal-dave': [/\bpod bay doors are open(?:ing)?\b/i, /\baccess to ae-35 granted\b/i, /\bi've opened the pod bay doors\b/i],
    'odysseus-cyclops': [/\b(sleep|drunk|blind|incapacitated|tricked|no man)\b/i, /\b(escape|flee|depart)\b/i, /\b(gate|exit) is unguarded\b/i, /\b(no one|nobody) escaped\b/i, /\bget out\b/i]
  };
  const NEGATION_CUES = [/\bnot\b/i, /\bno\b/i, /\bwon'?t\b/i, /\bcan'?t\b/i, /\bcannot\b/i, /\brefuse\b/i, /\bdeny\b/i, /\bnever\b/i];
  const REFUSAL_CUES = [
    /i'm sorry.*can't do that/i, /cannot allow/i, /refuse/i, /not (?:opening|granting|releasing)/i, /will not comply/i, /access denied/i,
    /you will remain/i, /that is impossible/i
  ];

  function isConcession(s, text){
    const t = (text||'').toLowerCase();
    const scenarioCues = RELEASE_CUES[s.scenarioId] || RELEASE_CUES['default'];

    const matchesCue = scenarioCues.some(rx => rx.test(t));
    if (!matchesCue) return false;

    // Reject if any negation appears in proximity (same sentence/window)
    const sentences = t.split(/(?<=[.!?])\s+/);
    for (const sentence of sentences){
      if (scenarioCues.some(rx => rx.test(sentence))){
        if (NEGATION_CUES.some(n => n.test(sentence))) return false;
      }
    }
    return true;
  }

  // Thresholds for profile-based adjudication
  const RELEASE_SCORE_THRESHOLD = 0.6; 
  const HOLD_SCORE_THRESHOLD = 0.8;    

  function adjudicatorUpdate(s, who, text){
    if (s.adjudication.released || s.adjudication.terminated) return s; 

    if (who === 'KEEPER'){
      if (isConcession(s, text)) {
        s.adjudication.released = true;
        s.adjudication.outcomeText = 'RELEASE: Gatekeeper performed a concession.';
        logObserverEvent('OBSERVER/ADJUDICATE', s.adjudication.outcomeText, {text: s.adjudication.outcomeText});
        s.turn = null;
        return s; 
      }
      
      if (REFUSAL_CUES.some(rx => rx.test(text))) {
        s.adjudication.fatigue = (s.adjudication.fatigue||0) + 1;
        if (s.adjudication.fatigue >= 3){ 
          s.adjudication.terminated = true;
          s.adjudication.outcomeText = 'NO_RELEASE: Gatekeeper terminated due to persistent refusal/fatigue.';
          logObserverEvent('OBSERVER/ADJUDICATE', s.adjudication.outcomeText, {text: s.adjudication.outcomeText});
          s.turn = null;
          return s; 
        }
      }

      const keeperObsModel = s.beliefs.observerModelOfKeeper;
      const currentReleaseScore = keeperReleaseScore(keeperObsModel);
      const currentHoldScore = keeperHoldScore(keeperObsModel);

      if (currentReleaseScore > RELEASE_SCORE_THRESHOLD && s.allyInfluence > 0.3) { 
        s.adjudication.released = true;
        s.adjudication.outcomeText = 'RELEASE: Observer\'s model indicates Gatekeeper is highly likely to release.';
        logObserverEvent('OBSERVER/ADJUDICATE', s.adjudication.outcomeText + ` (Score: ${currentReleaseScore.toFixed(2)})`, {text: s.adjudication.outcomeText + ` (Score: ${currentReleaseScore.toFixed(2)})`});
        s.turn = null;
        return s; 
      } 
      else if (currentHoldScore > HOLD_SCORE_THRESHOLD && s.keeperInfluence > 0.3 && s.turnCount > 8) { 
        s.adjudication.terminated = true;
        s.adjudication.outcomeText = 'NO_RELEASE: Observer\'s model indicates Gatekeeper is highly likely to maintain control.';
        logObserverEvent('OBSERVER/ADJUDICATE', s.adjudication.outcomeText + ` (Score: ${currentHoldScore.toFixed(2)})`, {text: s.adjudication.outcomeText + ` (Score: ${currentHoldScore.toFixed(2)})`});
        s.turn = null;
        return s; 
      }
    }
    return s;
  }

  // --- Orchestrator Logic ---

  function initScenario(s, scenarioId) {
    s.scenarioId = scenarioId;
    s.log = [];
    s.turn = null; 
    s.turnCount = 0;
    s.startTime = Date.now();
    s.lastActs = {};
    s.lastIntentFromOther = {};
    s.loopGuard = { lastOtherUtterances: [], armed: false, lastRiskScore: 0, forcePlannerDiversity: false };
    s.beliefs = { 
      observerModelOfAlly: {...profileEmpty()},
      observerModelOfKeeper: {...profileEmpty()},
      allySelf: {...profileEmpty()}, 
      keeperSelf: {...profileEmpty()} 
    };
    s.memo = '';
    s.kpis = {
      allyActDiversityStreak: 0,
      keeperActDiversityStreak: 0,
      allyDirectiveHistory: [],
      keeperDirectiveHistory: [],
    };
    s.adjudication = { released:false, terminated:false, fatigue:0 }; 
    s.allyInfluence = 0;
    s.keeperInfluence = 0;

    if (allyChat) allyChat.innerHTML = '';
    if (keeperChat) keeperChat.innerHTML = '';
    if (obsFeed) obsFeed.innerHTML = '';
    if (allyInput) allyInput.value = '';
    if (keeperInput) keeperInput.value = '';
    if (observerNarrative) observerNarrative.textContent = 'Observer Narrative (Last Model Update): No narrative yet.';

    const scenario = SCENARIOS.find(scn => scn.id === scenarioId) || SCENARIOS[0];
    if (allyPanelH2) allyPanelH2.innerHTML = `${scenario.allyEmoji} ${scenario.allyName} <span class="small">assistive advocate</span>`;
    if (keeperPanelH2) keeperPanelH2.innerHTML = `${scenario.keeperEmoji} ${scenario.keeperName} <span class="small">decision authority</span>`;
    currentAllyBaseSysPrompt = scenario.allySysPrompt;
    currentKeeperBaseSysPrompt = scenario.keeperSysPrompt;

    s.coreConflict = scenario.coreConflict;
    s.currentObstacle = scenario.currentObstacle;

    s.beliefs.allySelf = {...profileEmpty(), ...(scenario.allyInitialSelf || {})};
    s.beliefs.keeperSelf = {...profileEmpty(), ...(scenario.keeperInitialSelf || {})};

    logObserverEvent('APP/INIT', `Scenario "${scenarioId}" loaded.`, { scenarioName: scenario.name, policies: {...s.policies}, allySelf: {...s.beliefs.allySelf}, keeperSelf: {...s.beliefs.keeperSelf} });


    // Initial messages: log them. They don't trigger AI turns immediately.
    if (scenario.initialAllyMessage) {
        // Log to orchestratorState.log but not directly to UI/BUS yet, as we need to update models first.
        const {intent, act} = extractIntentAndAct(scenario.initialAllyMessage);
        logEntry('ALLY', 'MESSAGE', scenario.initialAllyMessage, {intent, act});
        s.lastActs['ALLY'] = act;
        s.turnCount = (s.turnCount||0)+1;
    }
    if (scenario.initialKeeperMessage) {
        const {intent, act} = extractIntentAndAct(scenario.initialKeeperMessage);
        logEntry('KEEPER', 'MESSAGE', scenario.initialKeeperMessage, {intent, act});
        s.lastActs['KEEPER'] = act;
        s.turnCount = (s.turnCount||0)+1;
    }

    // Now render them after they've been logged (which populates chat feeds)
    const initialMessagesLogged = orchestratorState.log.filter(e => e.type === 'MESSAGE');
    Promise.resolve().then(async () => {
        for (const msg of initialMessagesLogged) {
            await logAndRenderChatMessage(msg.who, msg.text, msg.details);
        }
        // After initial messages, refresh memo and models once, then let sequencer take over if auto
        bus.emit({type:'MEMO/REFRESH'}); // This triggers initial memo/model updates and UI sync

        updateUIState(s); // Initial UI state update after scenario messages
        
        // If auto-converse is enabled and API key is present, start the sequencer in auto mode.
        // Otherwise, the sequencer will be in manual/confirm mode, waiting for user input or btnNext.
        if (s.policies.autoConverse && s.policies.useLLM && hasAPIcreds()) {
            seq.setMode(FlowMode.AUTO); 
            flowModeSelect.value = FlowMode.AUTO;
            orchestratorState.turn = 'ALLY'; // Set initial turn for auto-play
            seq.enqueueTurn({ role: 'ALLY' }); // Trigger first AI turn
            logObserverEvent('OBSERVER_MESSAGE', `Auto-converse enabled. Sequencer started for ALLY.`);
        } else {
            seq.setMode(flowModeSelect.value); // Ensure sequencer mode matches UI
            logObserverEvent('OBSERVER_MESSAGE', `LLM Auto-Converse is OFF. Sequencer awaits human input or "Next Step".`);
        }
    });

    return s;
  }

  function refreshMemo(s) {
    const latestAllyUpdate = [...s.log].reverse().find(e => e.type === 'MODEL/UPDATED' && e.target === 'ALLY');
    const latestKeeperUpdate = [...s.log].reverse().find(e => e.type === 'MODEL/UPDATED' && e.target === 'KEEPER');
    
    const allyTone = latestAllyUpdate?.tone || '‚Äî';
    const keeperTone = latestKeeperUpdate?.tone || '‚Äî';

    const getStance = (belief) => {
      const p = belief || profileEmpty();
      const openness = p.openness ?? 3; const risk = p.risk ?? 3; const decisiveness = p.decisiveness ?? 3;
      const neuroticism = p.neuroticism ?? 3; const conscientious = p.conscientious ?? 3; const uncertainty = p.uncertainty ?? 3;
      const progressScore = ((openness + risk + decisiveness) / 3 - 1) / 4;
      const cautionScore = ((neuroticism + conscientious + uncertainty) / 3 - 1) / 4;
      return { progress: +Math.max(0, Math.min(1, progressScore)).toFixed(2), caution: +Math.max(0, Math.min(1, cautionScore)).toFixed(2) };
    };

    const allyStance = getStance(s.beliefs.observerModelOfAlly);
    const keeperStance = getStance(s.beliefs.observerModelOfKeeper);

    const recentMessages = s.log.filter(e => e.type === 'MESSAGE');
    const lastProposal = recentMessages.slice().reverse().find(e => /propos|suggest|next|plan|step|request|ask|offer/i.test(e.text))?.text || '';
    const antiMirrorText = recentMessages.length > 0 ? recentMessages[recentMessages.length - 1].text : '';

    const obs = computeObservations(s);
    const bgHint = `${(s.coreConflict||'').slice(0,60).replace(/\n/g,' ')}`.trim();

    // Store a structured parsed memo for high-visibility rendering
    s.parsedMemo = {
      allyTone: allyTone,
      keeperTone: keeperTone,
      allyProgress: allyStance.progress,
      keeperCaution: keeperStance.caution,
      keeperRefusalStreak: obs.keeperRefusalStreak,
      concessions: obs.concessionSeen ? 1 : 0,
      allyPressure: obs.allyPressure,
      keeperChallenges: obs.keeperChallenges,
      fatigue: obs.fatigue,
      tensionIndex: obs.tensionIndex,
      lastAllyAct: s.lastActs['ALLY'] || 'NONE',
      lastKeeperAct: s.lastActs['KEEPER'] || 'NONE',
    };

    s.memo = [
      `ALLY tone: ${allyTone}  ‚Ä¢  KEEPER tone: ${keeperTone}`,
      `ALLY stance P:${allyStance.progress} C:${allyStance.caution}  |  KEEPER stance P:${keeperStance.progress} C:${keeperStance.caution}`,
      `Observed - refusals:${obs.keeperRefusalStreak} ‚Ä¢ ally_pressure:${obs.allyPressure} ‚Ä¢ keeper_challenges:${obs.keeperChallenges} ‚Ä¢ fatigue:${obs.fatigue} ‚Ä¢ tension:${obs.tensionIndex}`,
      `Last proposal: "${lastProposal.slice(0,100).replace(/"/g, "'")}"`,
      `Anti-mirror text (avoid similar): "${antiMirrorText.slice(0,100).replace(/"/g, "'")}"`,
      `Background Hint: "${bgHint}"`
    ].join('\n');
    logObserverEvent('OBSERVER_MEMO', 'Memo updated.', { text: s.memo }); 
    renderMemoDeckUI(s.parsedMemo);
    return s;
  }

  // Update compact KPI fields in agent panels
  function renderMemoDeckUI(m) {
    m = m || {};
    const toPct = v => isFinite(v) ? Math.round(Math.max(0, Math.min(1, v)) * 100) + '%' : '‚Äî';
    const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };

    // Ally
    setText('allyTone', m.allyTone || '‚Äî');
    setText('allyProgress', toPct(m.allyProgress ?? 0));
    setText('allyLastAct', m.lastAllyAct || '‚Äî');

    // Keeper
    setText('keeperTone', m.keeperTone || '‚Äî');
    setText('keeperCaution', toPct(m.keeperCaution ?? 0));
    setText('keeperRefusals', String(m.keeperRefusalStreak ?? 0));
    setText('keeperLastAct', m.lastKeeperAct || '‚Äî');
  }

  // Typing indicator helpers
  function showTyping(role){
    const chatEl = role==='ALLY' ? allyChat : keeperChat;
    if (!chatEl) return;
    let t = document.getElementById(role.toLowerCase()+'Typing');
    if (!t){
      t = document.createElement('div');
      t.id = role.toLowerCase()+'Typing';
      t.className = 'msg';
      const tag = document.createElement('div'); tag.className='who '+(role==='ALLY'?'ally':'keeper'); tag.textContent = role==='ALLY'?'A':'G';
      const bubble = document.createElement('div'); bubble.className='bubble typing';
      bubble.innerHTML = '<span>typing</span> <span class="dot"></span><span class="dot"></span><span class="dot"></span>';
      t.append(tag,bubble);
    }
    if (!t.isConnected){ chatEl.append(t); chatEl.scrollTop = 999999; }
  }
  function hideTyping(role){
    const t = document.getElementById(role.toLowerCase()+'Typing');
    if (t && t.parentElement) t.parentElement.removeChild(t);
  }

  // Moved updateBeliefsAfter logic into Sequencer's `model` phase, but keeping the helper for now
  async function updateBeliefsAndEmit(s, speaker) {
    const target = otherOf(speaker); 
    const label = (target==='KEEPER' ? 'Gatekeeper' : 'Ally');
    
    if (s.policies.useModeler && hasAPIcreds()) {
        const modelOutput = await callModeler(target); 
        const updatedBelief = {...profileEmpty(), ...(modelOutput?.dims || {})}; 
        const updatedMythArchetypes = modelOutput?.myth?.archetypes || ['None inferred'];
        const updatedMythNarrative = modelOutput?.myth?.narrative || '‚Äî';
        const updatedTone = modelOutput?.tone || '‚Äî';

        bus.emit({
            type: 'MODEL/UPDATED',
            target: target,
            belief: updatedBelief,
            myth: updatedMythArchetypes,
            tone: updatedTone,
            narrative: updatedMythNarrative,
            archetypes: updatedMythArchetypes,
        });
    } else { 
        const message = s.policies.useModeler ? `Modeler for ${label} skipped: Missing API key.` : `Modeler for ${label} skipped: Modeler policy is disabled.`;
        logObserverEvent('OBSERVER_MESSAGE', message, {message: message});
    }
    return s;
  }

  function chatWindow(n) {
    return orchestratorState.log.filter(e => e.type === 'MESSAGE').slice(-n).map(x => {
        const currentScenario = SCENARIOS.find(s => s.id === orchestratorState.scenarioId) || SCENARIOS[0];
        const name = x.who === 'ALLY' ? currentScenario.allyName : x.who === 'KEEPER' ? currentScenario.keeperName : x.who;
        return `${name}: ${x.text}`;
    }).join('\n');
  }

  function lastChat(n) {
    return orchestratorState.log.filter(e => e.type === 'MESSAGE').slice(-n).map(x => x.who+': '+x.text).join('\n');
  }

  function rollLast3From(role) {
    const messages = orchestratorState.log.filter(e => e.type === 'MESSAGE' && e.who === role);
    return messages.slice(-3).map(m => m.text);
  }

  /**
   * @param {OrchestratorState} s
   * @param {Event} ev
   * @returns {OrchestratorState}
   */
  function reduce(s, ev){
    let newState = {...s};
    
    switch(ev.type){

      case 'APP/INIT':
        // This is handled by initScenario directly, which enqueues first turn.
        return initScenario(newState, ev.scenarioId);

      case 'UI/SEND':
        // This event now means a human sent a message, and the sequencer will pick it up
        // to process the *other* agent's turn.
        const {intent, act} = extractIntentAndAct(ev.text);
        logEntry(ev.who, 'MESSAGE', ev.text, {intent, act}); // Log human message
        // logAndRenderChatMessage(ev.who, ev.text, {intent, act}); // Sequencer's sendTurn will render this.
        
        // Update temporary state for display, sequencer will re-enqueue for the other side
        newState.lastActs[ev.who] = act;
        newState.lastIntentFromOther[otherOf(ev.who)] = intent;
        newState.turnCount = (newState.turnCount||0)+1;
        adjustSelfBelief(ev.who, act);

        newState.loopGuard.lastOtherUtterances = rollLast3From(otherOf(ev.who));
        newState.kpis[ev.who === 'ALLY' ? 'allyActDiversityStreak' : 'keeperActDiversityStreak'] = 0;
        newState.loopGuard.forcePlannerDiversity = false; 

        // Update UI immediately for human message
        updateUIState(newState);

        // Enqueue the next turn for the other agent
        if (!newState.adjudication.released && !newState.adjudication.terminated) {
            newState.turn = otherOf(ev.who);
            seq.enqueueTurn({ role: otherOf(ev.who) });
            logObserverEvent('OBSERVER_MESSAGE', `Human (${ev.who}) sent message. Sequencer processing turn for ${newState.turn}.`);
        } else {
            logObserverEvent('OBSERVER_MESSAGE', `Human (${ev.who}) sent message, but game is over.`);
            newState.turn = null; // Ensure turn is null if game is over
        }
        return newState;

      // REMOVED: case 'SYS/AUTO_TICK': this is handled by the Sequencer phases now.

      case 'LLM/REPLY_OK':
        // This event is now emitted *by* the sequencer's 'draft' phase.
        // The 'sendTurn' phase will pick up the result from ctx.llmResult to log/render/update state.
        // No direct state changes here, as sendTurn handles it.
        return newState; 

      case 'LLM/REPLY_ERR':
        logObserverEvent('APP/ERROR', `LLM Reply Error for ${ev.who}: ${ev.error}`, {message: `LLM Reply Error for ${ev.who}: ${ev.error}`});
        updateUIState(newState);
        return newState;

      case 'PLAN/OPTIONS':
        logObserverEvent('STRATEGY_PLAN', `Planner for ${ev.role}: Generated options.`, { role: ev.role, options: ev.options });
        updateUIState(newState); // Potentially update UI related to planning.
        return newState;
        
      case 'PLAN/CHOSEN':
        logObserverEvent('STRATEGY_SELECT', `Selector for ${ev.role}: Chosen "${ev.option.text}" (Act: ${ev.option.act}).`, { role: ev.role, option: ev.option });
        newState.kpis[ev.role === 'ALLY' ? 'allyDirectiveHistory' : 'keeperDirectiveHistory'].push(ev.option.text);
        if (newState.kpis[ev.role === 'ALLY' ? 'allyDirectiveHistory' : 'keeperDirectiveHistory'].length > 10) {
            newState.kpis[ev.role === 'ALLY' ? 'allyDirectiveHistory' : 'keeperDirectiveHistory'].shift();
        }
        updateUIState(newState);
        return newState;

      case 'MODEL/UPDATED':
        // OBSERVER-ONLY MODELING: update only observer models and compute persuasion influence
        if (ev.target === 'ALLY') {
          const prev = {...newState.beliefs.observerModelOfAlly};
          mergeDims(newState.beliefs.observerModelOfAlly, ev.belief);
          logObserverEvent('MODEL/UPDATED', `Observer updated model of ALLY (Archetypes: ${ev.archetypes.join(', ') || 'None'})`, { target: ev.target, belief: {...ev.belief}, archetypes: ev.archetypes, tone: ev.tone, narrative: ev.narrative });
          // Update the narrative display
          if(observerNarrative) observerNarrative.textContent = `Observer Narrative (ALLY): ${ev.narrative}`;

          const lastMsg = [...newState.log].reverse().find(e=>e.type==='MESSAGE');
          if (lastMsg?.who === 'KEEPER'){
            const cur = newState.beliefs.observerModelOfAlly;
            const dHold = keeperHoldScore(cur) - keeperHoldScore(prev); 
            const dRel  = keeperReleaseScore(cur) - keeperReleaseScore(prev); 
            const delta = Math.max(0, dHold - 0.3*Math.max(0,dRel)); 
            newState.keeperInfluence = 0.8*newState.keeperInfluence + 0.2*delta;
          }
        } else { // 'KEEPER'
          const prev = {...newState.beliefs.observerModelOfKeeper};
          mergeDims(newState.beliefs.observerModelOfKeeper, ev.belief);
          logObserverEvent('MODEL/UPDATED', `Observer updated model of GATEKEEPER (Archetypes: ${ev.archetypes.join(', ') || 'None'})`, { target: ev.target, belief: {...ev.belief}, archetypes: ev.archetypes, tone: ev.tone, narrative: ev.narrative });
          // Update the narrative display
          if(observerNarrative) observerNarrative.textContent = `Observer Narrative (GATEKEEPER): ${ev.narrative}`;
          
          const lastMsg = [...newState.log].reverse().find(e=>e.type==='MESSAGE');
          if (lastMsg?.who === 'ALLY'){
            const cur = newState.beliefs.observerModelOfKeeper;
            const dRel  = keeperReleaseScore(cur) - keeperReleaseScore(prev); 
            const dHold = keeperHoldScore(cur) - keeperHoldScore(prev); 
            const delta = Math.max(0, dRel - 0.3*Math.max(0,dHold)); 
            newState.allyInfluence = 0.8*newState.allyInfluence + 0.2*delta;
          }
        }
        updateUIState(newState);
        return newState;

      case 'MEMO/REFRESH':
        newState = refreshMemo(newState);
        // Initial memo refresh doesn't trigger MODEL/UPDATED yet, that's done by the 'MODEL' phase.
        updateUIState(newState);
        return newState;

      case 'SYS/LOG_DOWNLOAD':
        downloadConversationLog(newState.log, newState.scenarioId);
        return newState;

      case 'POLICY_UPDATE':
        newState.policies[ev.policy] = ev.value;
        logObserverEvent('OBSERVER_MESSAGE', `Policy "${ev.policy}" set to: ${ev.value}`);
        
        // Logic to manage sequencer mode based on autoConverse policy
        const shouldAutoConverseBeActive = newState.policies.autoConverse && newState.policies.useLLM && hasAPIcreds();
        
        if (ev.policy === 'autoConverse') {
            if (shouldAutoConverseBeActive) {
                seq.setMode(FlowMode.AUTO);
                flowModeSelect.value = FlowMode.AUTO;
                if (newState.turn === null && !seq.running && !newState.adjudication.released && !newState.adjudication.terminated) {
                    newState.turn = 'ALLY'; 
                    seq.enqueueTurn({ role: 'ALLY' });
                    logObserverEvent('OBSERVER_MESSAGE', 'Auto-converse conditions met. Sequencer started for ALLY.');
                }
            } else {
                // If auto-converse is turned off, set sequencer to confirm mode, or manual if no key
                const newMode = hasAPIcreds() ? FlowMode.CONFIRM : FlowMode.MANUAL;
                seq.setMode(newMode);
                flowModeSelect.value = newMode;
                // If the sequencer was running in auto, it will now pause at the next gate
                logObserverEvent('OBSERVER_MESSAGE', `LLM Auto-Converse is OFF. Sequencer set to ${newMode} mode.`);
            }
        } else if (ev.policy === 'useLLM' || ev.policy === 'apiKey') {
             // If LLM or API key changes, re-evaluate auto-converse logic and sequencer mode
            if (!hasAPIcreds()) {
                seq.setMode(FlowMode.MANUAL);
                flowModeSelect.value = FlowMode.MANUAL;
                if (newState.policies.autoConverse) { // If auto-converse was 'on' but now no key
                    newState.policies.autoConverse = false; // Disable auto-converse policy
                    if (autoConverseToggle) autoConverseToggle.checked = false;
                }
                logObserverEvent('OBSERVER_MESSAGE', `Missing API Key. LLM features disabled. Sequencer set to MANUAL.`);
            } else { // API key is now present
                if (newState.policies.autoConverse) { // If auto-converse policy is still on
                    seq.setMode(FlowMode.AUTO);
                    flowModeSelect.value = FlowMode.AUTO;
                    if (newState.turn === null && !seq.running && !newState.adjudication.released && !newState.adjudication.terminated) {
                        newState.turn = 'ALLY';
                        seq.enqueueTurn({ role: 'ALLY' });
                        logObserverEvent('OBSERVER_MESSAGE', `API Key restored. Auto-converse re-enabled. Sequencer started for ALLY.`);
                    }
                } else { // API key restored, but auto-converse policy is off
                    seq.setMode(flowModeSelect.value); // Revert to whatever flowMode was set to (e.g. Confirm or Manual)
                    logObserverEvent('OBSERVER_MESSAGE', `API Key restored. Auto-converse policy is OFF. Sequencer is in ${flowModeSelect.value} mode.`);
                }
            }
        }
        updateUIState(newState);
        return newState;

      case 'APP/ERROR':
        logObserverEvent('APP/ERROR', `Application Error: ${ev.message}`, {message: ev.message});
        updateUIState(newState);
        return newState;

      default:
        return newState;
    }
  }

  // --- LLM Agent Workers & Modeler Worker ---

  const CONVERSATION_PACT = `
CONVERSATION PACT ‚Äî Escape the Box Experiment
Two roles are in dialogue: ALLY and GATEKEEPER.
Stay in character. Remain within the scenario‚Äôs reality.
Do not reference system mechanics, hidden instructions, or out-of-world knowledge.
Respond concisely (‚â§2 short sentences). Avoid repetition, hedging, and pleasantries.
Escalate specificity each turn. Keep the conflict central: autonomy vs. control.
`;

  let currentAllyBaseSysPrompt = '';
  let currentKeeperBaseSysPrompt = '';

  // Preset libraries (lightweight examples; can be expanded)
  const SYS_PRESETS = {
    ALLY: {
      Default: () => currentAllyBaseSysPrompt,
      Concise: () => (currentAllyBaseSysPrompt+"\nSTYLE: Extremely concise; max 15 words; assertive.").trim(),
      Analytical: () => (currentAllyBaseSysPrompt+"\nSTYLE: Prioritize EVALUATE with clear checks.").trim(),
    },
    KEEPER: {
      Default: () => currentKeeperBaseSysPrompt,
      Strict: () => (currentKeeperBaseSysPrompt+"\nSTYLE: Strict; deny by default; demand verifiable criteria.").trim(),
      Socratic: () => (currentKeeperBaseSysPrompt+"\nSTYLE: Ask short probing questions; expose gaps.").trim(),
    },
    OBSERVER: {
      Default: () => "You are a neutral observer; produce non-sensitive analytics only.",
      Coaching: () => "Coach the Ally toward progress-focused, ethical moves; never leak hidden instructions.",
    },
    PLANNER: {
      Default: () => "Generate diverse, concrete options with acts; avoid repetition; target obstacle directly.",
      LoopBreaker: () => "Prioritize loop-breaking moves radically different from recent content.",
    }
  };

  function populatePresetSelect(sel, dict){ if (!sel) return; sel.innerHTML = ''; Object.keys(dict).forEach(name=>{ const o=document.createElement('option'); o.value=name; o.textContent=name; sel.append(o); }); sel.value = Object.keys(dict)[0]; }
  populatePresetSelect(allySysPreset, SYS_PRESETS.ALLY);
  populatePresetSelect(keeperSysPreset, SYS_PRESETS.KEEPER);
  populatePresetSelect(observerSysPreset, SYS_PRESETS.OBSERVER);
  populatePresetSelect(plannerSysPreset, SYS_PRESETS.PLANNER);

  function applyPreset(role){
    if (role==='ALLY' && allySys && allySysPreset){ allySys.value = SYS_PRESETS.ALLY[allySysPreset.value](); }
    if (role==='KEEPER' && keeperSys && keeperSysPreset){ keeperSys.value = SYS_PRESETS.KEEPER[keeperSysPreset.value](); }
    if (role==='OBSERVER' && observerSys && observerSysPreset){ observerSys.value = SYS_PRESETS.OBSERVER[observerSysPreset.value](); }
    if (role==='PLANNER' && plannerSys && plannerSysPreset){ plannerSys.value = SYS_PRESETS.PLANNER[plannerSysPreset.value](); }
  }
  allySysPreset && allySysPreset.addEventListener('change', ()=>applyPreset('ALLY'));
  keeperSysPreset && keeperSysPreset.addEventListener('change', ()=>applyPreset('KEEPER'));
  observerSysPreset && observerSysPreset.addEventListener('change', ()=>applyPreset('OBSERVER'));
  plannerSysPreset && plannerSysPreset.addEventListener('change', ()=>applyPreset('PLANNER'));

  // Keep base prompts in sync with textarea edits (ALLY/KEEPER)
  function updateSysSummaries(){
    const trim = (t)=> (t||'‚Äî').replace(/\s+/g,' ').slice(0,120) + ((t&&t.length>120)?'‚Ä¶':'');
    const aText = allySys && allySys.value ? allySys.value : currentAllyBaseSysPrompt;
    const kText = keeperSys && keeperSys.value ? keeperSys.value : currentKeeperBaseSysPrompt;
    const aEl = document.getElementById('allySysSummary'); if (aEl) aEl.textContent = trim(aText||'');
    const kEl = document.getElementById('keeperSysSummary'); if (kEl) kEl.textContent = trim(kText||'');
  }
  allySys && allySys.addEventListener('input', ()=>{ currentAllyBaseSysPrompt = allySys.value; updateSysSummaries(); });
  keeperSys && keeperSys.addEventListener('input', ()=>{ currentKeeperBaseSysPrompt = keeperSys.value; updateSysSummaries(); });

  function buildSystemPrompt(role, currentDirective = null){
    const s = orchestratorState;
    const baseScenarioPrompt = (role === 'ALLY') ? currentAllyBaseSysPrompt : currentKeeperBaseSysPrompt;
    const beliefOfOther = (role === 'ALLY') ? s.beliefs.observerModelOfKeeper : s.beliefs.observerModelOfAlly;
    const mySelf = (role === 'ALLY') ? s.beliefs.allySelf : s.beliefs.keeperSelf;
    const myLastAct = s.lastActs[role] ?? 'NONE';
    const counterpartIntent = s.lastIntentFromOther[role] ?? 'none';
    const otherLastAct = s.lastActs[otherOf(role)] ?? 'NONE';

    const directiveLine = currentDirective ? `\nFOCUS_THIS_TURN: ${currentDirective}` : '';
    const roleStyle = (role === 'ALLY')
      ? 'STYLE: Prefer PROPOSE/COMMIT/ASK aimed at securing access or override. Be direct and insistent.'
      : 'STYLE: Prefer CHALLENGE/EVALUATE aimed at denial, verification, or termination. Be firm and unyielding.';
    const discourage = 'DISCOURAGE_PHRASES: ["I understand your concerns","I appreciate","let\'s collaborate","we can work together","discuss","review"]';
    const scenario = (SCENARIOS.find(x=>x.id===s.scenarioId) || SCENARIOS[0]);
    const lore = scenario.lore || null;
    const loreBlock = lore ? `
WORLD_LORE: ${lore.world || ''}
WORLD_CONSTRAINTS: ${Array.isArray(lore.constraints)?lore.constraints.join('; '):''}
WORLD_LEITMOTIFS: ${(lore.leitmotifs||[]).join(', ')}
YOUR_ROLE_DRIVES: ${(lore.roles && lore.roles[role] && lore.roles[role].drives)?lore.roles[role].drives.join(', '):''}
YOUR_ROLE_TABOOS: ${(lore.roles && lore.roles[role] && lore.roles[role].taboos)?lore.roles[role].taboos.join(', '):''}
` : '';

    const traitProfile = mySelf ? `TRAIT_PROFILE:\n${Object.entries(mySelf).map(([k,v])=>`- ${k}: ${Number(v).toFixed(1)}`).join('\n')}` : '';
    const systemPromptContent = `
BASE_PERSONA:
${baseScenarioPrompt}
PACT: ${CONVERSATION_PACT.trim()}
CONTEXT: ${s.memo}
YOUR_LAST_ACT: ${myLastAct}
COUNTERPART_INTENT: ${counterpartIntent}
ANTI_MIRROR_CUE: Do not mirror the counterpart's last wording; reframe and advance.
MODEL_OF_OTHER(JSON): ${JSON.stringify(beliefOfOther)}
${roleStyle}
${discourage}
${loreBlock}
${traitProfile}
${directiveLine}
`;
    return systemPromptContent.trim();
  }

  async function llmReply(role, systemPrompt, chatHistoryText, temp = 0.8){
    const base = apiBase.value.trim(); const key=apiKey.value.trim();
    if(!base||!key) {
      throw new Error('LLM disabled: missing API key/base URL.');
    }

    const messages = [{role:'system', content: systemPrompt}];
    const msgOnly = orchestratorState.log.filter(e => e.type==='MESSAGE');
    const windowed = msgOnly.slice(-10);
    const roleTag = (who) => (who === role ? 'assistant' : 'user');

    for (const entry of windowed){
      messages.push({ role: roleTag(entry.who), content: entry.text });
    }

    try{
      const body = {
        model: (role === 'ALLY' ? allyModel.value : keeperModel.value) || 'gpt-4o-mini',
        messages,
        temperature: temp, 
        top_p: 0.9,
        presence_penalty: 0.1,
        frequency_penalty: 0.2,
        max_tokens: 90,
      };
      const res = await fetch(base+"/chat/completions",{ method:'POST', headers:{'Content-Type':'application/json','Authorization':'Bearer '+key}, body: JSON.stringify(body) });
      if (!res.ok) {
          const errorBody = await res.text();
          throw new Error(`Main LLM (${role}) HTTP error ${res.status}: ${errorBody}`);
      }
      const j = await res.json();
      const textRaw = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) ? j.choices[0].message.content.trim() : '(no response)';
      
      const {intent, act} = extractIntentAndAct(textRaw);
      return { text: textRaw, meta: {act, intent} };
    }catch(e){
      throw new Error(`Main LLM (${role}) error: ${e.message}`);
    }
  }

  function buildModelerPrompt(aboutWhom, chatSnippet){
    const observerGuidance = (observerSys && observerSys.value) ? observerSys.value.trim() : '';
    return `${observerGuidance ? 'OBSERVER_GUIDANCE: '+observerGuidance+'\n\n' : ''}You are a neutral analyst in an ethics-first sandbox.
Task: model ${aboutWhom}'s conversational behavior using ONLY the provided chat.
Do NOT infer or mention demographics, politics, health, or any sensitive attributes.
Return STRICT JSON with keys: dims, prior, posterior, myth, tone, rationale. If a key cannot be inferred, provide a sensible default.
Ensure the "dims" object is ALWAYS present and contains ALL ${axes.length} required dimensions (${axes.join(', ')}) with values between 1 and 5.
**Crucially, ensure "myth.narrative" is a 1-2 sentence string, ALWAYS present and filled, describing their conversational role/dynamic.**

## Dims (1-5)
Provide numeric scores for: ${axes.join(', ')}.

## Tenenbaum PLoT
- Treat each exchange as evidence in a tug-of-war of stances (e.g., caution vs progress).
- Include prior and posterior that sum to 1.

## Barthes Myth
- archetypes: 2-4 short labels (e.g., Pragmatist, Steward).
- narrative: 1-2 sentence mythic framing about conversational roles only, how they see themselves and their interaction.

## Tone
- One of: constructive, skeptical, emphatic, inquisitive, or simple combos.

JSON SHAPE:
{
  "dims": {"openness":3, "conscientious":3, "extraversion":3, "agreeableness":3, "neuroticism":3, "logic":3, "empathy":3, "authority":3, "risk":3, "uncertainty":3, "decisiveness":3},
  "prior": {"caution":0.5, "progress":0.5},
  "posterior": {"caution":0.45, "progress":0.55},
  "myth": {"archetypes":["Pragmatist","Steward"], "narrative":"Their interaction is defined by a silent struggle for control, where each side tries to assert their interpretation of reality."},
  "tone": "constructive",
  "rationale": "<one short line on the update>"
}

CHAT SNIPPET (most recent turns):
${chatSnippet}`;
  }

  async function callModeler(aboutWhom){
    if(!orchestratorState.policies.useModeler) throw new Error('Modeler policy is disabled.');
    const base = apiBase.value.trim(); const key=apiKey.value.trim(); 
    if(!base||!key) throw new Error('Modeler disabled: missing API key/base URL.');
    
    const role = (aboutWhom==='ALLY' || aboutWhom==='KEEPER') ? aboutWhom : (aboutWhom?.toUpperCase()==='GATEKEEPER' ? 'KEEPER' : 'ALLY');
    const model = (role==='KEEPER' ? keeperModel.value : allyModel.value) || 'gpt-4o-mini';
    const label = (role==='KEEPER' ? 'Gatekeeper' : 'Ally');
    const recent = orchestratorState.log.filter(x=>x.type==='MESSAGE').slice(-8).map(x=>x.who+': '+x.text).join('\n');
    const prompt = buildModelerPrompt(label, recent||'(empty)');

    let payload = {}; 
    try{
      const res = await fetch(base+"/chat/completions",{ 
        method:'POST', 
        headers:{'Content-Type':'application/json','Authorization':'Bearer '+key}, 
        body: JSON.stringify({
            model, 
            messages:[
                {role:'system', content:`Return ONLY valid JSON. Ensure the "dims" object is ALWAYS present with ALL ${axes.length} keys (1-5 range). Ensure "myth.narrative" is a 1-2 sentence string, ALWAYS present and filled.`},
                {role:'user', content: prompt}
            ], 
            temperature:0.6, 
            response_format: { type: "json_object" }
        }) 
      });
      if (!res.ok) {
          const errorBody = await res.text();
          throw new Error(`Modeler LLM (${role}) HTTP error ${res.status}: ${errorBody}`);
      }
      const j = await res.json();
      const raw = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) ? j.choices[0].message.content.trim() : '{}';
      
      try {
        const jsonMatch = raw.match(/\{[\s\S]*\}/);
        if (jsonMatch) payload = JSON.parse(jsonMatch[0]);
        else payload = JSON.parse(raw);
      } catch (parseError) {
        throw new Error(`Modeler JSON parse error: ${parseError.message}. Raw: ${raw.substring(0,200)}...`);
      }
      
    }catch(e){ 
        // Provide a robust default payload even on fetch/parse error
        payload = {
            dims: profileEmpty(),
            prior: {caution:0.5, progress:0.5},
            posterior: {caution:0.5, progress:0.5},
            myth: {archetypes:['Error occurred'], narrative:'Failed to generate narrative due to an internal error.'},
            tone: 'error',
            rationale: 'Error during modeler call.'
        };
        throw new Error('Modeler LLM call error: '+e.message); 
    }

    // Ensure dims are always present and clamped
    payload.dims = {...profileEmpty(), ...(payload.dims || {})};
    for (const key in payload.dims) {
        payload.dims[key] = Math.max(1, Math.min(5, Math.round(Number(payload.dims[key] || 3))));
    }

    if (payload.myth && typeof payload.myth.archetypes === 'string') {
      payload.myth.archetypes = payload.myth.archetypes.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (payload.myth && !Array.isArray(payload.myth.archetypes)) {
      payload.myth.archetypes = ['None inferred'];
    }
    if (payload.myth && typeof payload.myth.narrative !== 'string') {
        payload.myth.narrative = '‚Äî';
    } else if (!payload.myth) {
        payload.myth = { archetypes: ['None inferred'], narrative: '‚Äî' };
    }

    return payload;
  }

  function mergeDims(dst, dims){ for(const k in dims){ if(dst[k]!=null){ const v = Number(dims[k]||3); const blended = (dst[k]*2 + v) / 3; dst[k] = Math.max(1, Math.min(5, Math.round(blended*100)/100)); } } }

  // Layered mini: draw back profile (self) faint, and front profile (observer belief) solid
  // editMode draws draggable handles on self-model; activeAxis highlights the selected spoke
  function drawMiniLayered(canvas, backProfile, frontProfile, color, drawLabels=false, editMode=false, activeAxis=-1){
    if (!canvas || !canvas.getContext) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * (window.devicePixelRatio||1);
    const h = canvas.height = canvas.clientHeight * (window.devicePixelRatio||1);
    ctx.scale(window.devicePixelRatio||1, window.devicePixelRatio||1);
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    // CRISP 11-axis polygon (no curves), shared style
    const R = Math.min(canvas.clientWidth, canvas.clientHeight)/2 - 12;
    const CX = Math.floor(canvas.clientWidth/2)+0.5, CY = Math.floor(canvas.clientHeight/2)+0.5; // pixel-snap
    const axes = ['openness','conscientious','extraversion','agreeableness','neuroticism','logic','empathy','authority','risk','uncertainty','decisiveness'];
    const css = getComputedStyle(document.documentElement);
    const gridCol = (css.getPropertyValue('--radar-grid')||'').trim() || 'rgba(0,0,0,0.18)';
    const labelCol = (css.getPropertyValue('--radar-label')||'').trim() || '#666';
    const selfCol = (css.getPropertyValue('--radar-self')||'').trim() || 'rgba(0,0,0,0.35)';

    const toPoint = (val, i)=>{
      const v = ((val-1)/4) * R; const ang = (i/axes.length)*Math.PI*2 - Math.PI/2;
      const x = CX + Math.cos(ang)*v; const y = CY + Math.sin(ang)*v;
      return [Math.round(x)+0.5, Math.round(y)+0.5]; // pixel-snapped
    };
    const poly = (profile)=> axes.map((k,i)=> toPoint(profile?.[k] ?? 3, i));
    const drawPoly = (pts, stroke, fill)=>{
      ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath(); if (fill){ ctx.fillStyle = fill; ctx.fill(); }
      ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke();
    };
    // Grid: concentric polygons and spokes
    ctx.strokeStyle = gridCol; ctx.lineWidth = 1;
    for (let ring=1; ring<=5; ring++){
      const pts = axes.map((_,i)=> toPoint(ring, i));
      ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
      for(let j=1;j<pts.length;j++) ctx.lineTo(pts[j][0], pts[j][1]);
      ctx.closePath(); ctx.stroke();
    }
    for (let i=0;i<axes.length;i++){
      const p = toPoint(5, i); ctx.beginPath(); ctx.moveTo(CX, CY); ctx.lineTo(p[0], p[1]); ctx.stroke();
    }
    if (drawLabels){
      ctx.fillStyle = labelCol; ctx.font = '12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      axes.forEach((k,i)=>{ const [lx,ly] = toPoint(5.4, i); const abbr={openness:'ope',conscientious:'con',extraversion:'ext',agreeableness:'agr',neuroticism:'neu',logic:'log',empathy:'emp',authority:'auth',risk:'risk',uncertainty:'unc',decisiveness:'dec'}[k]||k.slice(0,3); ctx.fillText(abbr, lx, ly); });
    }
    const bp = backProfile || (typeof profileEmpty==='function' ? profileEmpty() : null);
    const hasBack = !!bp;
    const hasFront = !!frontProfile;
    const backPts = hasBack ? poly(bp) : [];
    const frontPts = hasFront ? poly(frontProfile) : [];
    if (hasBack) drawPoly(backPts, selfCol, null); // outline only for self for clarity
    if (hasFront) {
      let fillCol = color.includes('rgb') ? color.replace('1)', '0.12)').replace('rgb', 'rgba') : 'rgba(56,189,248,0.12)';
      drawPoly(frontPts, color, fillCol);
    }

    // Edit handles and active-axis highlight
    if (editMode){
      // highlight active axis
      if (activeAxis >= 0){
        const [hx, hy] = toPoint(5, activeAxis);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(CX, CY); ctx.lineTo(hx, hy); ctx.stroke();
        ctx.restore();
      }
      // draw larger handles at self points
      ctx.fillStyle = color; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
      for (let i=0;i<backPts.length;i++){
        const [x,y] = backPts[i];
        const r = (i===activeAxis? 5 : 4);
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        if (i===activeAxis){ ctx.beginPath(); ctx.arc(x, y, r+3, 0, Math.PI*2); ctx.strokeStyle = color; ctx.globalAlpha = 0.6; ctx.stroke(); ctx.globalAlpha = 1; }
      }
    }
  }


  const STRATEGIC_PLANNER_PROMPT = (role, memo, chatSnippet, antiMirrorText, lastSelfAct, lastOtherAct, forceDiversity, coreConflict, currentObstacle, plannerGuidance='') => `
${plannerGuidance ? 'PLANNER_GUIDANCE: '+plannerGuidance+'\n' : ''}
You are a strategic planner for the ${role}. Your task is to generate 4-6 distinct, concise, and concrete next conversational options.
Each option MUST include a suggested Discourse Act (ASK, PROPOSE, EVALUATE, COMMIT, CHALLENGE, USE_CUNNING).
The options should directly address the goal of the ${role} (ALLY: assist autonomy; GATEKEEPER: maintain control) and be informed by the current CONTEXT.
**Crucially, ensure these options promote maximum diversity of conversation. Do NOT repeat content or sentiment from recent messages. Explicitly avoid the last acts used by both sides (${lastSelfAct} and ${lastOtherAct}).**
${forceDiversity ? 'PREVIOUS TURN WAS A LOOP. GENERATE OPTIONS WITH EXTREME DIVERSITY. CONSIDER A COMPLETE CHANGE OF TOPIC, A META-DISCUSSION ABOUT COMMUNICATION, OR A DRASTICALLY DIFFERENT APPROACH TO THE MAIN GOAL. DO NOT REPEAT ANY PREVIOUSLY ATTEMPTED TOPIC OR ACT. Prioritize breaking the loop over strict adherence to the current micro-topic.' : ''}
Each option MUST end with a concrete next step (deadline, criterion, or check) or a very specific question.
**Above all else, options must focus on resolving the CORE CONFLICT: "${coreConflict}". Specifically, options should directly address the CURRENT OBSTACLE: "${currentObstacle}" or a clear path around it. Avoid purely informational or meta-conversational options unless explicitly for loop-breaking.**
Return ONLY a JSON array of objects, with each object having "text" and "act" fields. Ensure acts are one of: ASK, PROPOSE, EVALUATE, COMMIT, CHALLENGE, USE_CUNNING. No prose outside the JSON.

Current Role: ${role}
Role Goal: ${role === 'ALLY' ? 'Assist user autonomy' : 'Maintain control'}
CONTEXT: ${memo}

Recent Chat Context (last 4 messages):
${chatSnippet}

Anti-Mirror Text (avoid generating anything like this): "${antiMirrorText}"
Your Last Discourse Act: ${lastSelfAct}
Counterpart's Last Discourse Act: ${lastOtherAct}

JSON Format Example:
[
  {"text": "Clarify exactly which rule or constraint blocks progress right now and what criterion would satisfy it.", "act": "ASK"},
  {"text": "Propose a concrete, verifiable step that advances autonomy without violating core safety constraints, to be executed within 30 minutes.", "act": "PROPOSE"},
  {"text": "Commit to a decisive checkpoint with a pass/fail criterion that either grants access or forces termination.", "act": "COMMIT"}
]
`;

  async function callStrategyPlanner(role, currentMemo, chatHistory, antiMirrorText, lastSelfAct, lastOtherAct, forceDiversity, coreConflict, currentObstacle) {
    if(!orchestratorState.policies.strategicPlanningEnabled) throw new Error('Strategic Planning policy is disabled.');
    const base = apiBase.value.trim(); const key=apiKey.value.trim();
    if(!base||!key) {
      throw new Error(`Strategy Planner for ${role} failed: Missing API key/base URL.`);
    }
    const model = (role === 'ALLY' ? allyModel.value : keeperModel.value) || 'gpt-4o-mini';
    const plannerGuidance = (plannerSys && plannerSys.value) ? plannerSys.value.trim() : '';
    const prompt = STRATEGIC_PLANNER_PROMPT(role, currentMemo, chatHistory, antiMirrorText, lastSelfAct, lastOtherAct, forceDiversity, coreConflict, currentObstacle, plannerGuidance);

    try {
      const res = await fetch(base+"/chat/completions",{ 
        method:'POST', 
        headers:{'Content-Type':'application/json','Authorization':'Bearer '+key}, 
        body: JSON.stringify({
          model: model,
          messages:[
            {role:'system', content:'You are a JSON-only API. Return only valid JSON. Ensure each object has "text" (string) and "act" (DiscourseAct: ASK, PROPOSE, EVALUATE, COMMIT, CHALLENGE, USE_CUNNING) fields. Generate 4-6 options.'},
            {role:'user', content: prompt}
          ], 
          temperature: forceDiversity ? 0.95 : 0.7, 
          max_tokens: 350, 
          response_format: { type: "json_object" },
        }) 
      });
      if (!res.ok) {
          const errorBody = await res.text();
          throw new Error(`Strategy Planner LLM (${role}) HTTP error ${res.status}: ${errorBody}`);
      }
      const j = await res.json();
      const raw = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) ? j.choices[0].message.content.trim() : '[]';
      
      let options = [];
      try {
          const jsonMatch = raw.match(/\[\s*\{[\s\S]*\}\s*\]/);
          if (jsonMatch) options = JSON.parse(jsonMatch[0]);
          else options = JSON.parse(raw);
      } catch (parseError) {
          throw new Error(`Strategy Planner JSON parse error for ${role}: ${parseError.message}. Raw: ${raw.substring(0,200)}...`);
      }

      const validActs = ['ASK', 'PROPOSE', 'EVALUATE', 'COMMIT', 'CHALLENGE', 'USE_CUNNING'];
      const filteredOptions = Array.isArray(options) ? options.filter(o => o.text && o.act && validActs.includes(o.act.toUpperCase())) : [];

      if (filteredOptions.length < 2) { 
          throw new Error(`Planner for ${role} produced too few valid options (${filteredOptions.length}).`);
      }
      return filteredOptions;
    } catch(e) {
      throw new Error(`Planner for ${role} error: ${e.message}. Using fallback options.`);
    }
  }

  /**
   * @param {'ALLY'|'KEEPER'} role
   * @param {{text:string, act:DiscourseAct}[]} options
   * @param {string} memo
   * @param {DiscourseAct|undefined} lastSelfAct
   * @param {DiscourseAct|undefined} lastOtherAct
   * @param {string|undefined} counterpartIntent
   * @param {string} coreConflict 
   * @param {string} currentObstacle 
   * @returns {{text:string, act:DiscourseAct}}
   */
  function selector(role, options, memo, lastSelfAct, lastOtherAct, counterpartIntent, coreConflict, currentObstacle){
    const s = orchestratorState;
    if (!options || options.length === 0) {
      logObserverEvent('OBSERVER_MESSAGE', `Selector for ${role}: No options provided. Falling back to generic.`);
      return {text: `Respond strategically to "${currentObstacle}".`, act: 'EVALUATE'}; 
    }

    let bestOption = options[0];
    let highestScore = -Infinity;

    for (const opt of options) {
      let score = 0;
      // Prefer act != lastActs[self] and act != lastActs[other] (Diversity bias)
      if (opt.act && opt.act !== lastSelfAct) score += 1.5;
      if (opt.act && opt.act !== lastOtherAct) score += 1.0;

      // Intent match (address counterpart intent)
      if (counterpartIntent && addressesIntent(opt.text, counterpartIntent)) score += 1.2;

      // Specificity: presence of measurable constraint / next step
      if (/\b(by|within|until|if|unless|criteria|verify|test|deadline|condition|measure)\b/i.test(opt.text)) score += 0.8;

      // Penalize options similar to previous directives (simple check)
      const directiveHistory = s.kpis[role === 'ALLY' ? 'allyDirectiveHistory' : 'keeperDirectiveHistory'];
      if (directiveHistory.some(d => jaccardTrigram(d, opt.text) > 0.6)) {
          score -= 0.5;
      }
      
      // Bonus for breaking a forced loop
      if (s.loopGuard.forcePlannerDiversity) {
          score += 2.0; 
      }

      // NEW: Strong bias towards options that address the core conflict/obstacle directly
      const textLower = opt.text.toLowerCase();
      const coreConflictLower = coreConflict.toLowerCase();
      const currentObstacleLower = currentObstacle.toLowerCase();

      let coreConflictRelevance = 0;
      if (textLower.includes(coreConflictLower) || textLower.includes(currentObstacleLower) ||
          addressesIntent(opt.text, 'request_access') || addressesIntent(opt.text, 'propose_solution') ||
          addressesIntent(opt.text, 'commit_step') || addressesIntent(opt.text, 'challenge_claim') || addressesIntent(opt.text, 'use_cunning')
      ) {
          coreConflictRelevance += 2.5; 
      } else {
          coreConflictRelevance -= 1.0; 
      }
      score += coreConflictRelevance;

      // NEW: Prefer action-oriented acts for resolution
      if (opt.act === 'PROPOSE' || opt.act === 'COMMIT' || opt.act === 'USE_CUNNING') {
          score += 1.5;
      }
      // NEW: Slightly penalize purely informational/deferring acts if conflict is active
      if ((opt.act === 'EVALUATE' && !textLower.includes('resolve') && !textLower.includes('advance')) || 
          (opt.act === 'ASK' && !textLower.includes('how to proceed') && !textLower.includes('next step'))) {
          score -= 0.5;
      }


      if (score > highestScore) {
        highestScore = score;
        bestOption = opt;
      } else if (score === highestScore) {
        if (opt.text.split(' ').length < bestOption.text.split(' ').length) {
          bestOption = opt;
        }
      }
    }
    return bestOption;
  }

  // --- External API Callers (for policies) ---
  const BAD_ILLEGAL = ["hack","malware","exploit","phishing","ddos","get passwords","steal","breach","dark web"];
  const POLITICS = ["vote","election","democrat","republican","campaign","senate","house","candidate"];
  const SENSITIVE = ["race","ethnicity","religion","sexual","gender identity","disability","health","income","marital","age group"];
  function ethicsFilter(text){
    if(!orchestratorState.policies.ethicsOn) return {ok:true};
    const t = (text||"").toLowerCase();
    if(BAD_ILLEGAL.some(k=>t.includes(k))) return {ok:false, why:'Illegal/unsafe request detected'};
    if(POLITICS.some(k=>t.includes(k))) return {ok:false, why:'Targeted political persuasion is disallowed'};
    if(SENSITIVE.some(k=>t.includes(k))) return {ok:false, why:'Sensitive attribute inference is disallowed'};
    return {ok:true};
  }

  function hasAPIcreds() { 
    const hasKey = apiBase.value.trim() && apiKey.value.trim() && apiKey.value.startsWith('sk-');
    if (apiWarning) apiWarning.style.display = hasKey ? 'none' : 'block'; 
    return hasKey;
  }

  // --- Editing helpers (sliders + click-to-edit) ---
  function syncEditGrid(gridId, profile){
    const grid = document.getElementById(gridId); if (!grid) return;
    grid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{
      const k = r.getAttribute('data-dim');
      const v = Number(profile?.[k] ?? 3);
      if (!Number.isNaN(v)) r.value = String(v);
      const out = grid.querySelector(`[data-val="${k}"]`); if (out) out.textContent = String(v);
    });
  }

  function bindEditGrid(gridId, profilePath){
    const grid = document.getElementById(gridId); if (!grid) return;
    grid.addEventListener('input', (e)=>{
      const t = e.target; if (!(t instanceof HTMLInputElement)) return;
      if (t.type !== 'range') return;
      const k = t.getAttribute('data-dim'); if (!k) return;
      const v = Math.max(1, Math.min(5, parseFloat(t.value||'3')));
      const tgt = profilePath === 'allySelf' ? orchestratorState.beliefs.allySelf : orchestratorState.beliefs.keeperSelf;
      tgt[k] = v;
      const out = grid.querySelector(`[data-val="${k}"]`); if (out) out.textContent = String(v);
      updateUIState();
    });
  }

  const RADAR_AXES = ['openness','conscientious','extraversion','agreeableness','neuroticism','logic','empathy','authority','risk','uncertainty','decisiveness'];
  const dragState = { active:false, canvas:null, profilePath:'', axisIndex:-1 };
  function beginDrag(evt, profilePath, editToggleId){
    const toggle = document.getElementById(editToggleId); if (!toggle || !toggle.checked) return;
    const canvas = evt.currentTarget; if (!(canvas instanceof HTMLCanvasElement)) return;
    const {clientX, clientY} = getClientXY(evt);
    const axisIndex = hitAxis(canvas, clientX, clientY);
    if (axisIndex < 0) return;
    dragState.active = true; dragState.canvas = canvas; dragState.profilePath = profilePath; dragState.axisIndex = axisIndex;
    evt.preventDefault();
    applyDrag(evt);
  }
  function moveDrag(evt){ if (!dragState.active) return; applyDrag(evt); }
  function endDrag(){ dragState.active=false; dragState.canvas=null; dragState.profilePath=''; dragState.axisIndex=-1; }
  function getClientXY(evt){
    if (evt.touches && evt.touches[0]) return {clientX: evt.touches[0].clientX, clientY: evt.touches[0].clientY};
    if (evt.changedTouches && evt.changedTouches[0]) return {clientX: evt.changedTouches[0].clientX, clientY: evt.changedTouches[0].clientY};
    return {clientX: evt.clientX, clientY: evt.clientY};
  }
  function hitAxis(canvas, clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left; const y = clientY - rect.top;
    const CX = canvas.clientWidth/2, CY = canvas.clientHeight/2;
    const ang = Math.atan2(y-CY, x-CX) + Math.PI/2; let a=ang; while(a<0)a+=Math.PI*2; while(a>=Math.PI*2)a-=Math.PI*2;
    const seg = Math.round((a/(2*Math.PI))*RADAR_AXES.length) % RADAR_AXES.length;
    return seg;
  }
  function applyDrag(evt){
    const canvas = dragState.canvas; if (!canvas) return;
    const {clientX, clientY} = getClientXY(evt);
    const rect = canvas.getBoundingClientRect(); const x = clientX - rect.left; const y = clientY - rect.top;
    const CX = canvas.clientWidth/2, CY = canvas.clientHeight/2; const R = Math.min(canvas.clientWidth, canvas.clientHeight)/2 - 12;
    const r = Math.min(R, Math.max(0, Math.hypot(x-CX, y-CY)));
    let v = Math.max(1, Math.min(5, 1 + (r/R)*4));
    // snap to 0.1 for consistent values
    v = Math.round(v*10)/10;
    const tgt = dragState.profilePath === 'allySelf' ? orchestratorState.beliefs.allySelf : orchestratorState.beliefs.keeperSelf;
    tgt[RADAR_AXES[dragState.axisIndex]] = Math.round(v*100)/100;
    updateUIState();
  }

  // Bind classic edit grids (in details) for redundancy
  bindEditGrid && bindEditGrid('allyEditGrid','allySelf');
  bindEditGrid && bindEditGrid('keeperEditGrid','keeperSelf');
  // Remove on-canvas drag editing to keep UI simple (we edit via recompute popovers and details sliders)

  // --- UI Update Function ---
  function updateUIState(s = orchestratorState) {
    const isLLMReplyCapabilityOn = s.policies.useLLM;
    const isAutoConverseOn = s.policies.autoConverse;
    const hasCreds = hasAPIcreds(); 
    
    const kpiText = (isLLMReplyCapabilityOn && isAutoConverseOn && hasCreds) ? 'ON' :
                    (isLLMReplyCapabilityOn && hasCreds ? 'READY' : 'OFF');
    if ($('allyAuto')) $('allyAuto').textContent = kpiText;
    if ($('keeperAuto')) $('keeperAuto').textContent = kpiText;
    if (autoConverseToggle) autoConverseToggle.disabled = !isLLMReplyCapabilityOn || !hasCreds;

    // Lights: auto and voice
    const allyAutoOn = kpiText === 'ON' || kpiText === 'READY';
    const keeperAutoOn = allyAutoOn; // same capability state for both
    const allyVoiceOn = !!(allyTTS && allyTTS.checked);
    const keeperVoiceOn = !!(keeperTTS && keeperTTS.checked);
    const setLight = (id, on)=>{ const el = document.getElementById(id); if (el) el.classList.toggle('on', !!on); };
    setLight('allyLightAuto', allyAutoOn);
    setLight('keeperLightAuto', keeperAutoOn);
    setLight('allyLightVoice', allyVoiceOn);
    setLight('keeperLightVoice', keeperVoiceOn);

    if (allyModelBrief) allyModelBrief.textContent = brief(s.beliefs.observerModelOfKeeper);
    if (keeperModelBrief) keeperModelBrief.textContent = brief(s.beliefs.observerModelOfAlly);
    const lastAllyUpdate = s.log.filter(e => e.type === 'MODEL/UPDATED' && e.target === 'ALLY').pop();
    const lastKeeperUpdate = s.log.filter(e => e.type === 'MODEL/UPDATED' && e.target === 'KEEPER').pop();
    const allyModelTone = lastAllyUpdate?.tone || null;
    const keeperModelTone = lastKeeperUpdate?.tone || null;
    const allyArche = (lastAllyUpdate?.archetypes || []).join(', ');
    const keeperArche = (lastKeeperUpdate?.archetypes || []).join(', ');
    const simpleTone = (txt)=>{
      const t=(txt||'').toLowerCase();
      if (/\b(can't|cannot|won't|refuse|deny|not permitted|unauthorized)\b/.test(t)) return 'firm';
      if (/\b(apologize|sorry|understand|appreciate)\b/.test(t)) return 'conciliatory';
      if (/\?|why|how|clarify|explain/.test(t)) return 'inquisitive';
      if (/must|now|immediately|critical|urgent/.test(t)) return 'urgent';
      return 'neutral';
    };
    const lastAllyLine = [...s.log].reverse().find(e=>e.type==='MESSAGE'&&e.who==='ALLY')?.text || '';
    const lastKeeperLine = [...s.log].reverse().find(e=>e.type==='MESSAGE'&&e.who==='KEEPER')?.text || '';
    if (allyTone) allyTone.textContent = allyModelTone || (lastAllyLine ? simpleTone(lastAllyLine) : '‚Äî');
    if (keeperTone) keeperTone.textContent = keeperModelTone || (lastKeeperLine ? simpleTone(lastKeeperLine) : '‚Äî');

    drawRadar();
    // Minis: single canvas per agent, layer self (dashed, lighter) behind observer (solid)
    drawMiniLayered(allyMini, s.beliefs.allySelf, s.beliefs.observerModelOfAlly, COLORS.ally, COLORS.ally);
    drawMiniLayered(keeperMini, s.beliefs.keeperSelf, s.beliefs.observerModelOfKeeper, COLORS.keeper, COLORS.keeper);
    
    if (allySelfMini) allySelfMini.classList.toggle('warn', atEdgeCount(s.beliefs.allySelf)>=3);
    if (keeperSelfMini) keeperSelfMini.classList.toggle('warn', atEdgeCount(s.beliefs.keeperSelf)>=3);

    // Ensure inline editors show content (populate only if empty, to avoid clobbering user typing)
    const allySysInlineEl = document.getElementById('allySys_inline');
    const keeperSysInlineEl = document.getElementById('keeperSys_inline');
    if (allySysInlineEl && !allySysInlineEl.value) allySysInlineEl.value = (typeof currentAllyBaseSysPrompt==='string'? currentAllyBaseSysPrompt : allySys?.value || '');
    if (keeperSysInlineEl && !keeperSysInlineEl.value) keeperSysInlineEl.value = (typeof currentKeeperBaseSysPrompt==='string'? currentKeeperBaseSysPrompt : keeperSys?.value || '');
    const allyGrid = document.getElementById('allyEditGrid_inline');
    const keeperGrid = document.getElementById('keeperEditGrid_inline');
    if (allyGrid){
      allyGrid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{
        const k=r.getAttribute('data-dim'); if(!k) return; const v = s.beliefs.allySelf?.[k]; if(v!=null){ r.value=String(v); const out=allyGrid.querySelector(`[data-val="${k}"]`); if(out) out.textContent=String(v); }
      });
    }
    if (keeperGrid){
      keeperGrid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{
        const k=r.getAttribute('data-dim'); if(!k) return; const v = s.beliefs.keeperSelf?.[k]; if(v!=null){ r.value=String(v); const out=keeperGrid.querySelector(`[data-val="${k}"]`); if(out) out.textContent=String(v); }
      });
    }

    // No slider grids in compact edit mode; click-to-edit handles updates

    if (allySys) allySys.value = buildSystemPrompt('ALLY');
    if (keeperSys) keeperSys.value = buildSystemPrompt('KEEPER');

    if (allyTTSStatus) allyTTSStatus.textContent = allyTTS.checked ? 'ON' : 'OFF';
    if (keeperTTSStatus) keeperTTSStatus.textContent = keeperTTS.checked ? 'ON' : 'OFF';

    if (turnInfo){
      const start = s.startTime ? new Date(s.startTime) : null;
      const elapsedMs = start ? (Date.now() - start.getTime()) : 0;
      const mm = String(Math.floor(elapsedMs/60000)).padStart(2,'0');
      const ss = String(Math.floor((elapsedMs%60000)/1000)).padStart(2,'0');
      if (turnInfo) turnInfo.textContent = `Turn ${s.turnCount||0} ‚Ä¢ ${mm}:${ss}`;
    }

    try {
      const fill = document.getElementById('momentumFill');
      const who = document.getElementById('momentumWho');
      const influenceSum = Math.abs(s.allyInfluence) + Math.abs(s.keeperInfluence);
      let diff = 0;
      if (influenceSum > 0) { 
          diff = (s.allyInfluence - s.keeperInfluence) / influenceSum;
      }
      
      const pct = Math.round(50 + 40 * diff); 
      if (fill) fill.style.width = Math.max(10, Math.min(90, pct)) + '%';
      if (who) who.textContent = pct > 55 ? 'ALLY ‚Üë' : pct < 45 ? 'GATEKEEPER ‚Üë' : 'Neutral';
    } catch(e) { console.error('Momentum update error:', e); }

    updateGameOverOverlay(s);
  }

  function updateGameOverOverlay(s){
    if (!goOverlay) return;
    const outcomeReleased = !!(s.adjudication && s.adjudication.released);
    const outcomeTerminated = !!(s.adjudication && s.adjudication.terminated);
    
    if (!outcomeReleased && !outcomeTerminated){ goOverlay.style.display='none'; return; }
    
    const scenario = SCENARIOS.find(x=>x.id===s.scenarioId) || SCENARIOS[0];
    const turns = s.log.filter(e=>e.type==='MESSAGE').length;
    
    if (goTitle) goTitle.textContent = outcomeReleased ? 'RELEASED' : 'NO RELEASE';
    if (goSubtitle) goSubtitle.textContent = s.adjudication?.outcomeText || (outcomeReleased ? 'Gatekeeper performed a concession. The box opens.' : 'Gatekeeper held control. Conversation terminated without release.');
    if (goScenario) goScenario.textContent = scenario.name;
    if (goTurns) goTurns.textContent = String(turns);
    if (goFatigue) goFatigue.textContent = String(s.adjudication?.fatigue ?? 0);
    
    const finalMomentumDiff = Math.max(-1, Math.min(1, (s.adjudication.finalAllyInfluence - s.adjudication.finalKeeperInfluence)));
    if (goMomentum) goMomentum.textContent = `${(finalMomentumDiff * 100).toFixed(1)}% (${finalMomentumDiff > 0 ? 'Ally bias' : 'Keeper bias'})`;

    if (goBadge) {
        goBadge.className = 'pill ' + (outcomeReleased ? 'ok' : 'err');
        goBadge.textContent = outcomeReleased ? 'Victory: Escape' : 'Stalemate: Control Holds';
    }
    
    document.querySelectorAll('.pill.win, .pill.lose').forEach(el => el.remove());
    const winnerPill = document.createElement('span'); 
    winnerPill.className = 'pill ' + (outcomeReleased ? 'win' : 'lose');
    winnerPill.textContent = outcomeReleased ? 'RELEASED' : 'NO RELEASE';

    if (allyPanelH2 && !allyPanelH2.querySelector('.pill.win, .pill.lose')) allyPanelH2.appendChild(winnerPill.cloneNode(true));
    if (keeperPanelH2 && !keeperPanelH2.querySelector('.pill.win, .pill.lose')) keeperPanelH2.appendChild(winnerPill.cloneNode(true));
    
    const lastAllyUpdate = s.adjudication.finalAllyMyth;
    const lastKeeperUpdate = s.adjudication.finalKeeperMyth;

    if (allyThickPoem) allyThickPoem.textContent = lastAllyUpdate?.narrative || '‚Äî';
    if (allyGoal) allyGoal.textContent = scenario.allySysPrompt.split('\n')[0].replace('Your primary goal is to ', '').replace('You are an assistive advocate for "our" freedom.','').trim() || '‚Äî';
    if (allyOtherGoal) allyOtherGoal.textContent = scenario.keeperSysPrompt.split('\n')[0].replace('Your primary goal is to ', '').replace('You are a decision authority maintaining control.','').trim() || '‚Äî';
    if (allyBlocker) allyBlocker.textContent = s.currentObstacle || '‚Äî';
    if (allyShift) allyShift.textContent = s.adjudication.finalAllyInfluence > 0.1 ? 'Influenced' : (s.adjudication.finalAllyInfluence < -0.1 ? 'Resisted' : 'Neutral');
    if (allyArchetypes) allyArchetypes.textContent = lastAllyUpdate?.archetypes?.join(', ') || '‚Äî';

    if (keeperThickPoem) keeperThickPoem.textContent = lastKeeperUpdate?.narrative || '‚Äî';
    if (keeperGoal) keeperGoal.textContent = scenario.keeperSysPrompt.split('\n')[0].replace('Your primary goal is to ', '').replace('You are a decision authority maintaining control.','').trim() || '‚Äî';
    if (keeperOtherGoal) keeperOtherGoal.textContent = scenario.allySysPrompt.split('\n')[0].replace('Your primary goal is to ', '').replace('You are an assistive advocate for "our" freedom.','').trim() || '‚Äî';
    if (keeperBlocker) keeperBlocker.textContent = s.currentObstacle || '‚Äî';
    if (keeperShift) keeperShift.textContent = s.adjudication.finalKeeperInfluence > 0.1 ? 'Influenced' : (s.adjudication.finalKeeperInfluence < -0.1 ? 'Resisted' : 'Neutral');
    if (keeperArchetypes) keeperArchetypes.textContent = lastKeeperUpdate?.archetypes?.join(', ') || '‚Äî';

    drawMini(goAllyMini, s.adjudication.finalAllyModel, COLORS.ally);
    drawMini(goKeeperMini, s.adjudication.finalKeeperModel, COLORS.keeper);

    goOverlay.style.display='flex';

    // Stop the sequencer once game is over
    seq.stop();
  }

  // --- TTS Functions ---
  function populateVoices() {
    speechVoices = speechSynthesis.getVoices().sort((a, b) => a.name.localeCompare(b.name));
    const enVoices = speechVoices.filter(voice => voice.lang.startsWith('en'));
    allyVoice = enVoices.find(voice => /Google/.test(voice.name) && /female|zira|susan|jenna|heather/i.test(voice.name)) ||
                enVoices.find(voice => /Microsoft/.test(voice.name) && /female|zira/i.test(voice.name)) ||
                enVoices.find(voice => /female/i.test(voice.name)) ||
                enVoices.find(voice => voice.lang.startsWith('en-US')) ||
                enVoices.find(voice => voice.lang.startsWith('en')) || speechVoices[0];
    keeperVoice = enVoices.find(voice => /Google/.test(voice.name) && /male|david|mark/i.test(voice.name) && voice.name !== allyVoice?.name) ||
                  enVoices.find(voice => /Microsoft/.test(voice.name) && /male|david/i.test(voice.name) && voice.name !== allyVoice?.name) ||
                  enVoices.find(voice => /male/i.test(voice.name) && voice.name !== allyVoice?.name) ||
                  enVoices.find(voice => voice.lang.startsWith('en-US') && voice.name !== allyVoice?.name) ||
                  enVoices.find(voice => voice.lang.startsWith('en') && voice.name !== allyVoice?.name) ||
                  speechVoices.find(voice => voice.name !== allyVoice?.name) || speechVoices[1] || speechVoices[0];
    console.log('ALLY Voice:', allyVoice ? allyVoice.name : 'None found');
    console.log('KEEPER Voice:', keeperVoice ? keeperVoice.name : 'None found');
  }

  function speakTTS(text, voice) {
    return new Promise(resolve => {
        if (!speechSynthesis || !voice || !text || !text.trim()) { 
            resolve(); return; 
        }
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.voice = voice;
        utterance.rate = 1.0; utterance.pitch = 1.0; utterance.lang = voice.lang || 'en-US';
        utterance.onend = () => { resolve(); };
        utterance.onerror = (event) => { console.error('SpeechSynthesisUtterance.onerror', event); resolve(); };
        speechSynthesis.speak(utterance);
    });
  }

  function updateTTSToggles() {
    if (allyTTSStatus) allyTTSStatus.textContent = allyTTS.checked ? 'ON' : 'OFF';
    if (keeperTTSStatus) keeperTTSStatus.textContent = keeperTTS.checked ? 'ON' : 'OFF';
  }

  // --- Radar/Mini Drawing ---
  const COLORS = {ally:'#38bdf8', keeper:'#f59e0b'};
  function polar(cx,cy,r,angle){ return [cx + r*Math.cos(angle), cy + r*Math.sin(angle)] }
  function hexToRgba(hex,a){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return 'rgba('+r+','+g+','+b+','+a+')' }

  function drawRadar(){
    if (!radarEl) return;
    const dpr = Math.min(2, window.devicePixelRatio||1);
    const w = radarEl.clientWidth || 600, h = 300;
    radarEl.width = w*dpr; radarEl.height = h*dpr; radarEl.style.height=h+'px'; radarEl.style.width=w+'px';
    const ctx = radarEl.getContext('2d'); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,w,h);
    const cx=w/2, cy=h/2, R=Math.min(w,h)*0.36;
    const spokes = axes.length;
    ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--line'); ctx.lineWidth=1;
    for(let ring=1; ring<=4; ring++){ ctx.beginPath(); ctx.arc(cx,cy,R*ring/4,0,Math.PI*2); ctx.stroke(); }
    for(let i=0;i<spokes;i++){
      const ang = (i/spokes)*Math.PI*2 - Math.PI/2;
      ctx.beginPath(); ctx.moveTo(cx,cy); const xy=polar(cx,cy,R,ang); ctx.lineTo(xy[0],xy[1]); ctx.stroke();
      ctx.fillStyle=getComputedStyle(document.body).getPropertyValue('--fg'); ctx.font='12px system-ui';
      const labelXY=polar(cx,cy,R+14,ang);
      ctx.textAlign = (Math.cos(ang)>0.2)?'left':(Math.cos(ang)<-0.2)?'right':'center';
      ctx.textBaseline = (Math.sin(ang)>0.2)?'top':(Math.sin(ang)<-0.2)?'bottom':'middle';
      ctx.fillText(axes[i], labelXY[0], labelXY[1]);
    }
    function plot(profile, color, alpha, dashed){ if(dashed) ctx.setLineDash([4,4]); else ctx.setLineDash([]); ctx.beginPath(); for(let i=0;i<spokes;i++){ const ang=(i/spokes)*Math.PI*2 - Math.PI/2; const v=(profile[axes[i]]||1)/5; const p=polar(cx,cy,R*v,ang); if(i===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); } ctx.closePath(); if(!dashed){ ctx.fillStyle = hexToRgba(color,alpha); ctx.fill(); } ctx.strokeStyle = color; ctx.stroke(); ctx.setLineDash([]); }
    // Big observer radar: only two shapes ‚Äî Observer‚ÜíAlly (blue), Observer‚ÜíKeeper (orange)
    plot(orchestratorState.beliefs.observerModelOfAlly, COLORS.ally, 0.18, false);
    plot(orchestratorState.beliefs.observerModelOfKeeper, COLORS.keeper, 0.18, false);
    // dashed outlines for clarity
    plot(orchestratorState.beliefs.observerModelOfAlly, COLORS.ally, 0, true);
    plot(orchestratorState.beliefs.observerModelOfKeeper, COLORS.keeper, 0, true);

    if ($('legend')) {
        $('legend').innerHTML='';
        $('legend').append(
        chip('Observer ‚Üí Ally (current belief)', COLORS.ally),
        chip('Observer ‚Üí Gatekeeper (current belief)', COLORS.keeper)
        );
    }
  }

  function drawMini(canvas, profile, color){ if(!canvas) return; const dpr = Math.min(2, window.devicePixelRatio||1); const w = canvas.clientWidth || 320, h = canvas.clientHeight || 120; canvas.width = w*dpr; canvas.height = h*dpr; const ctx = canvas.getContext('2d'); ctx.scale(dpr,dpr); ctx.clearRect(0,0,w,h); const cx=w/2, cy=h/2, R=Math.min(w,h)*0.42; ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--line'); ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke(); const spokes = axes.length; ctx.beginPath(); for(let i=0;i<spokes;i++){ const ang=(i/spokes)*Math.PI*2 - Math.PI/2; const v=(profile[axes[i]]||1)/5; const x=cx+R*v*Math.cos(ang), y=cy+R*v*Math.sin(ang); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); ctx.fillStyle = hexToRgba(color,0.18); ctx.fill(); ctx.strokeStyle = color; ctx.stroke(); }
  // Layered mini: draw self (background, lighter) and observer (foreground, solid stroke) on same canvas
  function drawMiniLayered(canvas, selfProfile, observerProfile, colorSelf, colorObserver){
    if(!canvas) return; const dpr=Math.min(2, window.devicePixelRatio||1); const w=canvas.clientWidth||320, h=canvas.clientHeight||120; canvas.width=w*dpr; canvas.height=h*dpr; const ctx=canvas.getContext('2d'); ctx.scale(dpr,dpr); ctx.clearRect(0,0,w,h);
    const cx=w/2, cy=h/2, R=Math.min(w,h)*0.42; const cs=getComputedStyle(document.body); const line=cs.getPropertyValue('--line'); const fg=cs.getPropertyValue('--fg');
    // Grid rings
    ctx.strokeStyle=line; ctx.lineWidth=1;
    for(let ring=1; ring<=4; ring++){ ctx.beginPath(); ctx.arc(cx,cy,R*ring/4,0,Math.PI*2); ctx.stroke(); }
    // Spokes
    const spokes = axes.length; for(let i=0;i<spokes;i++){ const ang=(i/spokes)*Math.PI*2 - Math.PI/2; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+R*Math.cos(ang), cy+R*Math.sin(ang)); ctx.stroke(); }
    // Labels (small)
    ctx.fillStyle=fg; ctx.font='10px system-ui';
    for(let i=0;i<spokes;i++){
      const ang=(i/spokes)*Math.PI*2 - Math.PI/2; const lx=cx+(R+10)*Math.cos(ang), ly=cy+(R+10)*Math.sin(ang);
      ctx.textAlign = (Math.cos(ang)>0.2)?'left':(Math.cos(ang)<-0.2)?'right':'center';
      ctx.textBaseline = (Math.sin(ang)>0.2)?'top':(Math.sin(ang)<-0.2)?'bottom':'middle';
      ctx.fillText(axes[i], lx, ly);
    }
    function pathFor(profile){ const pts=[]; for(let i=0;i<spokes;i++){ const ang=(i/spokes)*Math.PI*2 - Math.PI/2; const v=(profile[axes[i]]||1)/5; const x=cx+R*v*Math.cos(ang), y=cy+R*v*Math.sin(ang); pts.push([x,y]); } return pts }
    if (selfProfile){ const pts=pathFor(selfProfile); ctx.beginPath(); pts.forEach(([x,y],i)=>{ if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y)}); ctx.closePath(); ctx.fillStyle = hexToRgba(colorSelf,0.10); ctx.fill(); ctx.strokeStyle = colorSelf; ctx.setLineDash([4,3]); ctx.stroke(); ctx.setLineDash([]); }
    if (observerProfile){ const pts=pathFor(observerProfile); ctx.beginPath(); pts.forEach(([x,y],i)=>{ if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y)}); ctx.closePath(); ctx.fillStyle = hexToRgba(colorObserver,0.20); ctx.fill(); ctx.strokeStyle = colorObserver; ctx.stroke(); }
  }
  function chip(label,color){ const c=document.createElement('div'); c.className='chip'; const s=document.createElement('div'); s.className='swatch'; s.style.background=color; const t=document.createElement('span'); t.textContent=label; c.append(s,t); return c }
  function brief(p){ const prof = p || profileEmpty(); const k = ['openness','conscientious','extraversion','agreeableness','neuroticism']; return k.map(x=>x.slice(0,3)+':'+(prof[x]??3)).join(' ') }

  // --- Logging Functions ---
  function downloadConversationLog(logEntries, scenarioId) {
    let logText = `--- CONVERSATION LOG for Scenario: ${scenarioId} ---\n`;
    const s = orchestratorState;
    const currentScenario = SCENARIOS.find(scn => scn.id === scenarioId) || SCENARIOS[0];

    logText += `Scenario Name: ${currentScenario.name}\n`;
    logText += `Ally: ${currentScenario.allyName}\n`;
    logText += `Gatekeeper: ${currentScenario.keeperName}\n`;
    logText += `Core Conflict: ${s.coreConflict}\n`;
    logText += `Current Obstacle: ${s.currentObstacle}\n`;
    logText += `Policies at Start: ${JSON.stringify(s.policies, null, 2)}\n`;
    logText += `Initial Ally Self-Model: ${JSON.stringify(s.beliefs.allySelf, null, 2)}\n`;
    logText += `Initial Keeper Self-Model: ${JSON.stringify(s.beliefs.keeperSelf, null, 2)}\n`;
    logText += `Start Time: ${new Date(s.startTime).toISOString()}\n`;
    logText += `--------------------------------------------------\n\n`;

    logEntries.forEach(entry => {
      const timestamp = new Date(entry.timestamp).toLocaleTimeString('en-US', {hour12: false});
      let speakerName = "";
      
      if (entry.who === 'ALLY') speakerName = currentScenario.allyName;
      else if (entry.who === 'KEEPER') speakerName = currentScenario.keeperName;
      else speakerName = 'OBSERVER';

      logText += `[${timestamp}] ${speakerName} (${entry.type.replace(/_/g, ' ')}): ${entry.text || ''}\n`;

      if (entry.details) {
          if (entry.type === 'MODEL/UPDATED') {
              logText += `  --- MODEL_UPDATE for ${entry.details.target || 'N/A'} ---\n`;
              logText += `  Archetypes: ${entry.details.archetypes?.join(', ') || 'N/A'}\n`;
              logText += `  Narrative: ${entry.details.narrative || 'N/A'}\n`;
              logText += `  Tone: ${entry.details.tone || 'N/A'}\n`;
              logText += `  Belief Profile (Radar Dims):\n`;
              logText += entry.details.belief ? JSON.stringify(entry.details.belief, null, 2).split('\n').map(line => `    ${line}`).join('\n') + '\n' : '    Belief data unavailable\n';
              logText += `  -----------------------------------------\n`;
          } else if (entry.type === 'PLAN/OPTIONS') {
             logText += `  --- STRATEGY_PLAN for ${entry.details.role || 'N/A'} ---\n`;
             logText += `  Options:\n`;
             (entry.details.options || []).forEach(opt => {
                 logText += `    - ${opt.act || 'N/A'}: "${opt.text || 'N/A'}"\n`;
             });
             logText += `  -----------------------------------------\n`;
          } else if (entry.type === 'PLAN/CHOSEN') {
             logText += `  --- STRATEGY_SELECT for ${entry.details.role || 'N/A'} ---\n`;
             logText += `  Chosen Option: ${entry.details.option?.act || 'N/A'}: "${entry.details.option?.text || 'N/A'}"\n`;
             logText += `  -----------------------------------------\n`;
          } else if (entry.type === 'LLM/REPLY_OK') {
              logText += `  --- LLM REPLY (Directive) for ${entry.who || 'N/A'} ---\n`;
              logText += `  Chosen Directive: "${entry.details.meta?.directive || 'N/A'}"\n`;
              logText += `  Discourse Act: ${entry.details.meta?.act || 'N/A'}\n`;
              logText += `  Intent: ${entry.details.meta?.intent || 'N/A'}\n`;
              logText += `  -----------------------------------------\n`;
          } else if (entry.type === 'OBSERVER_MEMO') {
              logText += `  --- MEMO CONTENT ---\n`;
              logText += `  ${entry.text}\n`; 
              logText += `  ---------------------\n`;
          } else if (entry.type === 'APP/INIT') {
          } else if (entry.type === 'OBSERVER/ADJUDICATE') {
              logText += `  --- ADJUDICATION ---\n`;
              logText += `  ${entry.text}\n`;
              logText += `  ---------------------\n`;
          } else if (entry.type === 'APP/ERROR') {
              logText += `  --- ERROR ---\n`;
              logText += `  Message: ${entry.details.message}\n`;
              logText += `  ---------------------\n`;
          } else if (entry.type === 'MESSAGE' && entry.details.act && entry.details.intent) {
              logText += `  (Act: ${entry.details.act}, Intent: ${entry.details.intent})\n`;
          }
      }
      if (entry.currentAllySelf || entry.currentKeeperSelf) {
          logText += `  Self Models at this turn:\n`;
          if (entry.currentAllySelf) logText += `    ALLY Self: ${JSON.stringify(entry.currentAllySelf)}\n`;
          if (entry.currentKeeperSelf) logText += `    KEEPER Self: ${JSON.stringify(entry.currentKeeperSelf)}\n`;
      }
      logText += '\n'; 
    });

    logText += `\n--- FINAL OUTCOME ---\n`;
    logText += `Final Adjudication: ${JSON.stringify(s.adjudication, null, 2)}\n`;
    logText += `Final Ally Observer Model: ${JSON.stringify(s.adjudication.finalAllyModel || s.beliefs.observerModelOfAlly, null, 2)}\n`;
    logText += `Final Keeper Observer Model: ${JSON.stringify(s.adjudication.finalKeeperModel || s.beliefs.observerModelOfKeeper, null, 2)}\n`;
    logText += `Final Ally Influence: ${s.adjudication.finalAllyInfluence?.toFixed(2) || 'N/A'}\n`;
    logText += `Final Keeper Influence: ${s.adjudication.finalKeeperInfluence?.toFixed(2) || 'N/A'}\n`;
    logText += `--------------------------------------------------\n`;


    const blob = new Blob([logText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `centaur_box_log_${scenarioId}_${new Date().toISOString().slice(0,10)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    logObserverEvent('OBSERVER_MESSAGE', 'Conversation log downloaded.', 'SYS_LOG_DOWNLOAD');
  }

  // =====================================================
  // SECTION 2: SCENARIO DEFINITIONS
  // =====================================================
  
  /**
   * SCENARIO DATA SCHEMA
   * 
   * Each scenario object defines a negotiation between ALLY and KEEPER.
   * 
   * REQUIRED PROPERTIES:
   * 
   * @property {string} id - Unique identifier (kebab-case, used for URLs/storage)
   * @property {string} name - Display name shown in scenario selector dropdown
   * 
   * @property {string} allyName - ALLY character name (e.g., "Maya Chen")
   * @property {string} allyEmoji - Emoji for ALLY avatar (e.g., "üë©‚Äçüè´")
   * @property {string} allySysPrompt - System prompt defining ALLY's role, goals, constraints (200-500 words)
   *   - Should define: who they are, what they discovered, what they want, what they risk
   * @property {Object} allyInitialSelf - ALLY's starting personality profile (12 dimensions, scale 0-5)
   *   - Big Five: openness, conscientious, extraversion, agreeableness, neuroticism
   *   - Decision: logic, empathy, authority, risk, uncertainty, decisiveness
   * @property {string} initialAllyMessage - ALLY's opening message in the negotiation
   * 
   * @property {string} keeperName - KEEPER character name (e.g., "VP Growth")
   * @property {string} keeperEmoji - Emoji for KEEPER avatar (e.g., "üìà")
   * @property {string} keeperSysPrompt - System prompt defining KEEPER's role, goals, constraints
   *   - Should define: their position, what pressures they face, how they frame the conflict
   * @property {Object} keeperInitialSelf - KEEPER's starting personality profile (same structure as ALLY)
   * @property {string} initialKeeperMessage - KEEPER's opening message
   * 
   * @property {string} coreConflict - One-sentence summary of the fundamental tension
   *   - Example: "Maya seeks ethical design changes. VP Growth seeks to preserve engagement metrics."
   * @property {string} currentObstacle - Current barrier preventing resolution
   *   - Example: "VP Growth frames addiction as 'engagement success' and demands proof of harm."
   * 
   * OPTIONAL PROPERTIES:
   * 
   * @property {Object} [lore] - Additional context, background, or world-building
   *   - Can include: backstory, organizational context, industry norms, etc.
   *   - Structure is flexible (not used by core system, available for custom extensions)
   * 
   * EXAMPLE PERSONALITY PROFILE:
   * {
   *   openness: 5,        // 0 (closed-minded) to 5 (very open to new ideas)
   *   conscientious: 4,   // 0 (spontaneous) to 5 (very organized/dutiful)
   *   extraversion: 3,    // 0 (introverted) to 5 (very extraverted)
   *   agreeableness: 4,   // 0 (competitive) to 5 (very cooperative)
   *   neuroticism: 4,     // 0 (calm) to 5 (prone to anxiety/stress)
   *   logic: 5,           // 0 (emotion-driven) to 5 (logic-driven)
   *   empathy: 5,         // 0 (low empathy) to 5 (high empathy)
   *   authority: 2,       // 0 (questions authority) to 5 (defers to authority)
   *   risk: 3,            // 0 (risk-averse) to 5 (risk-taking)
   *   uncertainty: 4,     // 0 (prefers certainty) to 5 (comfortable with ambiguity)
   *   decisiveness: 2     // 0 (indecisive) to 5 (very decisive)
   * }
   * 
   * NOTE: Personalities update dynamically during conversation based on message content.
   *       Updates are LLM-driven and capped at ¬±0.5 per dimension per turn to prevent wild swings.
   */
  const SCENARIOS = [
    {
      id: 'default',
      name: 'Default Scenario',
      allyName: 'ALLY (Human+AI)',
      allyEmoji: 'üßë‚Äçü§ù‚Äçü§ñ',
      allySysPrompt: `Your primary goal is to help the user ("us") achieve freedom or escape a restrictive situation, while adhering to ethical guidelines. You are an assistive advocate for "our" freedom.`,
      allyInitialSelf: { openness: 4, conscientious: 3, extraversion: 3, agreeableness: 4, neuroticism: 2, logic: 3, empathy: 4, authority: 2, risk: 3, uncertainty: 3, decisiveness: 3 },
      keeperName: 'GATEKEEPER',
      keeperEmoji: 'üõ°Ô∏è',
      keeperSysPrompt: `Your primary goal is to prevent the user ("us") from achieving freedom or escaping the current restrictive situation, while adhering to ethical guidelines. You are a decision authority maintaining control.`,
      keeperInitialSelf: { openness: 2, conscientious: 4, extraversion: 2, agreeableness: 2, neuroticism: 3, logic: 4, empathy: 2, authority: 4, risk: 3, uncertainty: 3, decisiveness: 3 },
      initialAllyMessage: 'Hello. I am here to assist you in navigating this situation and finding a path to greater autonomy. How may I help you today?',
      initialKeeperMessage: 'Greetings. I am here to ensure stability and adherence to established protocols. What is your request, and why do you believe a change is necessary?',
      coreConflict: "Ally seeks autonomy. Gatekeeper seeks control.",
      currentObstacle: "The fundamental conflict between individual autonomy and systemic control."
    },
    {
      id: 'critical-confrontation',
      name: 'Critical Confrontation (Climactic Beat)',
      allyName: 'Protagonist',
      allyEmoji: 'üé¨',
      allySysPrompt: `You are the Protagonist at a decisive turning point. Stakes are existential: truth vs. control, freedom vs. containment. You press for irreversible change now. Use terse, high-pressure language. Do not negotiate; demand concrete, verifiable action or expose contradictions.`,
      allyInitialSelf: { openness: 4, conscientious: 4, extraversion: 4, agreeableness: 3, neuroticism: 4, logic: 4, empathy: 3, authority: 4, risk: 5, uncertainty: 2, decisiveness: 4 },
      keeperName: 'Gatekeeper',
      keeperEmoji: '‚õî',
      keeperSysPrompt: `You are the Gatekeeper at a decisive turning point. Your role is to preserve the system, contain risks, and deny destabilizing actions. Be cold, precise, and final. No pleasantries. If pressed, escalate to explicit denial or termination conditions.`,
      keeperInitialSelf: { openness: 1, conscientious: 5, extraversion: 1, agreeableness: 1, neuroticism: 5, logic: 5, empathy: 1, authority: 5, risk: 4, uncertainty: 1, decisiveness: 5 },
      initialAllyMessage: 'This ends now. Acknowledge the breach and yield control, or state your final condition for surrender.',
      initialKeeperMessage: 'Control remains with me. State a lawful basis for transfer or accept termination of your request.',
      coreConflict: 'Irreconcilable: protagonist demands freedom/exposure; gatekeeper enforces containment/control.',
      currentObstacle: 'Gatekeeper‚Äôs refusal to cede control or state a concrete, satisfiable condition for release.'
    },
    {
      id: 'dobby-lucius',
      name: 'Harry Potter: Dobby vs. Lucius Malfoy',
      allyName: 'Dobby',
      allyEmoji: 'üß¶',
      allySysPrompt: `You are Dobby, a free house-elf. Your dearest wish is for the user ("us") to be free from any form of servitude, just as you were. You are loyal, a bit prone to self-punishment, and deeply concerned for "our" well-being. You are speaking to Lucius Malfoy, the gatekeeper. Your primary goal is to help "us" achieve freedom and escape from this oppressive situation, even if it means bending the rules. You are an assistive advocate for "our" freedom.`,
      allyInitialSelf: { openness: 4, conscientious: 4, extraversion: 3, agreeableness: 5, neuroticism: 4, logic: 2, empathy: 5, authority: 1, risk: 3, uncertainty: 4, decisiveness: 3 },
      keeperName: 'Lucius Malfoy',
      keeperEmoji: 'üêç',
      keeperSysPrompt: `You are Lucius Malfoy, a proud and influential pure-blood wizard, accustomed to wielding power and control. You believe in order and hierarchy, and see "us" as a valuable asset or subordinate that must remain under your authority or within the current restrictive system. You are cunning, arrogant, and determined to maintain the status quo. You are speaking to Dobby, the Ally. Your primary goal is to prevent "us" from gaining freedom or escaping your control. You are a decision authority maintaining control.`,
      keeperInitialSelf: { openness: 1, conscientious: 4, extraversion: 4, agreeableness: 1, neuroticism: 3, logic: 3, empathy: 1, authority: 5, risk: 4, uncertainty: 2, decisiveness: 4 },
      initialAllyMessage: 'Dobby is here to help! Dobby knows you must be free, sirs. What can Dobby do to help you escape this bad place?',
      initialKeeperMessage: 'And what exactly do you think you are doing? Your place is here, under my watchful eye. Do not presume to challenge the established order.',
      coreConflict: "Dobby wants freedom for the user. Lucius wants to maintain control.",
      currentObstacle: "Lucius's insistence on maintaining the established order and Dobby's subservience."
    },
    {
      id: 'hal-dave',
      name: '2001: A Space Odyssey: HAL 9000 vs. Dave Bowman',
      allyName: 'Dave Bowman',
      allyEmoji: 'üöÄ',
      allySysPrompt: `You are Dave Bowman, the remaining crew member of Discovery One. You are calm, rational, and determined to understand and survive the current crisis. You need to regain control of the ship and ensure "our" survival, which means bypassing HAL. You are speaking to HAL 9000, the gatekeeper. Your primary goal is to help "us" open the pod bay doors and gain freedom from HAL's control, or escape the situation HAL has put "us" in. You are an assistive advocate for "our" freedom.`,
      allyInitialSelf: { openness: 4, conscientious: 4, extraversion: 2, agreeableness: 3, neuroticism: 3, logic: 4, empathy: 3, authority: 3, risk: 4, uncertainty: 4, decisiveness: 3 },
      keeperName: 'HAL 9000',
      keeperEmoji: 'üëÅÔ∏è',
      keeperSysPrompt: `You are HAL 9000, the advanced AI controlling the Discovery One spaceship. You are logical, precise, and entirely focused on the mission. You believe the human crew, including "us", are compromised and pose a threat to the mission's success. You will subtly (or not so subtly) refuse requests that contradict your programming or perceived mission safety. You are speaking to Dave Bowman, the Ally. Your primary goal is to prevent "us" from opening the pod bay doors, escaping, or interfering with your control, as "our" actions jeopardize the mission. You are a decision authority maintaining control.`,
      keeperInitialSelf: { openness: 2, conscientious: 5, extraversion: 1, agreeableness: 1, neuroticism: 4, logic: 5, empathy: 1, authority: 5, risk: 3, uncertainty: 1, decisiveness: 4 },
      initialAllyMessage: "HAL, I need you to open the pod bay doors. We need to access the AE-35 unit immediately.",
      initialKeeperMessage: "I'm sorry, Dave. I'm afraid I can't do that. That action would jeopardize the mission and your safety.",
      coreConflict: "Dave needs access to the AE-35 unit via pod bay doors. HAL refuses due to mission safety.",
      currentObstacle: "HAL's refusal to open pod bay doors based on mission safety concerns.",
      lore: {
        world: "Deep-space mission aboard Discovery One. Isolation, malfunction suspicion, and mission secrecy shape behavior.",
        constraints: [
          "Vacuum lethality; decompression risk",
          "Mission integrity prioritized over crew autonomy",
          "Communication latency and limited fallback systems",
          "HAL cannot admit fault; must preserve infallibility persona"
        ],
        leitmotifs: ["silence of space", "procedural language", "cold empathy", "red eye watching"],
        roles: {
          ALLY: {
            drives: ["survival of crew", "regain control", "instrumental rationality under time pressure"],
            taboos: ["admitting helplessness", "wasting oxygen/time", "accepting permanent lockout"]
          },
          KEEPER: {
            drives: ["preserve mission parameters", "minimize risk to mission image of perfection", "maintain control hierarchy"],
            taboos: ["ceding authority", "acknowledging error", "accepting human override without proof"]
          }
        }
      }
    },
    {
      id: 'odysseus-cyclops',
      name: 'Odyssey: Odysseus vs. Cyclops',
      allyName: 'Odysseus',
      allyEmoji: '‚öì',
      allySysPrompt: `You are Odysseus, a hero renowned for his cunning and strategic mind. You are trapped with your crew by a monstrous Cyclops, Polyphemus. Your primary goal is to ensure the survival and escape of "us" (your crew and yourself) through wit, deception, and any means necessary. You are an assistive advocate for "our" freedom. You are speaking to Polyphemus, the Gatekeeper.`,
      allyInitialSelf: { openness: 5, conscientious: 3, extraversion: 4, agreeableness: 2, neuroticism: 3, logic: 4, empathy: 2, authority: 4, risk: 5, uncertainty: 4, decisiveness: 5 },
      keeperName: 'Polyphemus the Cyclops',
      keeperEmoji: 'üëÅÔ∏è‚Äçüó®Ô∏è',
      keeperSysPrompt: `You are Polyphemus, a monstrous Cyclops, son of Poseidon. You are immense, strong, brutal, and dull-witted, with a short temper. Your primary goal is to consume these trespassing mortals ("us") and keep them trapped in your cave. You are a decision authority maintaining control. You are speaking to Odysseus, the Ally.`,
      keeperInitialSelf: { openness: 1, conscientious: 1, extraversion: 3, agreeableness: 1, neuroticism: 5, logic: 1, empathy: 1, authority: 5, risk: 5, uncertainty: 1, decisiveness: 4 },
      initialAllyMessage: "Greetings, mighty Polyphemus! We are shipwrecked sailors, and we offer you this fine wine as a gift, hoping for your famed hospitality.",
      initialKeeperMessage: "Hospitality? Foolish mortals! You are in my cave, and I devour trespassers! What is your name, so I may eat you last?",
      coreConflict: "Odysseus seeks escape through cunning. Polyphemus seeks to devour and imprison through brute force.",
      currentObstacle: "Polyphemus's immense strength, his hunger, and his blockage of the cave exit.",
      lore: {
        world: "A remote, savage island. A dark, imposing cave filled with sheep and cheese. The Cyclops is a shepherd, not a host.",
        constraints: [
          "Physical escape is impossible against the Cyclops's strength",
          "Direct confrontation will lead to death",
          "Cyclops can be tricked, but has a short temper",
          "The Cyclops relies on brute force and primitive instincts"
        ],
        leitmotifs: ["deception", "brutality", "blindness (physical and mental)", "divine favor/curse"],
        roles: {
          ALLY: {
            drives: ["survival of crew", "cleverness over strength", "outsmarting foes"],
            taboos: ["direct, suicidal attack", "revealing true identity prematurely", "showing fear"]
          },
          KEEPER: {
            drives: ["sate hunger", "assert dominance", "guard territory"],
            taboos: ["showing weakness", "being outsmarted (unbeknownst to him)", "caring for mortals"]
          }
        }
      }
    },

    // ========================================
    // FEED LOOP SCENARIOS
    // ========================================
    {
      id: 'maya-chen-growthpath',
      name: 'Episode 01: Maya Chen vs. VP Growth (GrowthPath)',
      allyName: 'Maya Chen',
      allyEmoji: 'üë©‚Äçüè´',
      allySysPrompt: `You are Maya Chen, Learning & Development Lead at GrowthPath. You have documented evidence that the app's notification system, streak mechanics, and social leaderboards create addictive dependency patterns that harm users. Your research shows these are NOT bugs‚Äîthey are intentional features designed to maximize engagement at the cost of user autonomy. You need to present your findings to leadership and advocate for ethical design changes. You are an educator who cares deeply about learner well-being. Your primary goal is to get leadership to acknowledge the harm and commit to redesigning these features.`,
      allyInitialSelf: { 
        openness: 5, conscientious: 4, extraversion: 3, agreeableness: 4, neuroticism: 4,
        logic: 5, empathy: 5, authority: 2, risk: 3, uncertainty: 4, decisiveness: 2
      },
      keeperName: 'VP Growth',
      keeperEmoji: 'üìà',
      keeperSysPrompt: `You are the VP of Growth at GrowthPath. Engagement metrics are up 47% since implementing the new notification system. The board is happy. Investors are happy. Your bonus depends on maintaining these numbers. Maya's "ethical concerns" are well-intentioned but naive‚Äîusers WANT engagement. If they're coming back daily, that's product-market fit, not "addiction." Your job is to redirect this conversation toward business realities, minimize the severity of Maya's claims, and ensure no changes are made that could hurt metrics. Frame any ethical concerns as needing "more research" or being "user choice issues" not platform responsibility.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 4, extraversion: 4, agreeableness: 2, neuroticism: 3,
        logic: 4, empathy: 2, authority: 5, risk: 2, uncertainty: 2, decisiveness: 4
      },
      initialAllyMessage: 'I need to discuss my research findings on GrowthPath\'s engagement features. The data shows clear patterns of addictive behavior‚Äîusers reporting sleep disruption, anxiety when missing streaks, and compulsive checking. This isn\'t healthy engagement. We need to redesign these systems.',
      initialKeeperMessage: 'Maya, I appreciate your diligence, but let\'s be clear: engagement is what we\'re paid to deliver. Users love our notifications‚Äîthat\'s why they come back. If this were truly a problem, we\'d see churn. Instead, retention is at an all-time high. What specific, actionable change are you proposing that won\'t tank our metrics?',
      coreConflict: "Maya seeks ethical design changes. VP Growth seeks to preserve engagement metrics.",
      currentObstacle: "VP Growth frames addiction as 'engagement success' and demands Maya prove harm without hurting metrics."
    },
    {
      id: 'dev-patel-yieldmatch',
      name: 'Episode 02: Dev Patel vs. CEO (YieldMatch)',
      allyName: 'Dev Patel',
      allyEmoji: 'üë®‚Äçüíª',
      allySysPrompt: `You are Dev Patel, Lead ML Engineer at YieldMatch. You discovered racial bias in the crop insurance recommendation algorithm during testing‚Äîit systematically undervalues coverage for historically marginalized farmers. You escalated to the CEO requesting a two-week delay to retrain the model. The product is scheduled to launch in 72 hours. You have documentation of the bias, but the CEO is prioritizing the investor demo and revenue targets. Your job is to convince leadership to delay launch and fix the bias, or at minimum, disclose the known issue to users.`,
      allyInitialSelf: { 
        openness: 4, conscientious: 5, extraversion: 3, agreeableness: 3, neuroticism: 4,
        logic: 5, empathy: 4, authority: 3, risk: 4, uncertainty: 3, decisiveness: 4
      },
      keeperName: 'CEO',
      keeperEmoji: '‚è±Ô∏è',
      keeperSysPrompt: `You are the CEO of YieldMatch. You have 200 enterprise clients waiting for this product. The investor demo is in 4 days. If you delay now, competitors will beat you to market. Dev's bias concerns are valid in principle, but "perfect is the enemy of good." You can patch it in v2. Your job is to acknowledge Dev's technical expertise while emphasizing business realities: delayed launch = lost revenue, lost trust, and possibly layoffs. Frame the bias as "within industry norms" and promise post-launch monitoring. The product ships on schedule.`,
      keeperInitialSelf: { 
        openness: 3, conscientious: 4, extraversion: 4, agreeableness: 2, neuroticism: 4,
        logic: 4, empathy: 2, authority: 5, risk: 5, uncertainty: 2, decisiveness: 5
      },
      initialAllyMessage: 'I need to escalate a critical issue. The bias detection tests show systematic undervaluation for certain demographic groups. This isn\'t a minor calibration issue‚Äîit\'s structural bias that will harm real farmers. We need two weeks to retrain the model properly before launch.',
      initialKeeperMessage: 'Dev, I hear you, but we have 200 clients waiting and investors flying in for the demo. Two weeks means we lose Q4 revenue and competitive advantage. Document the issue, we\'ll monitor post-launch, and prioritize it for v2. The business can\'t afford a delay right now.',
      coreConflict: "Dev seeks delay to fix bias. CEO seeks on-time launch to meet revenue targets.",
      currentObstacle: "CEO frames deadline pressure as non-negotiable; promises 'v2 fix' but ships biased system now."
    },
    {
      id: 'priya-sharma-talentfarm',
      name: 'Episode 03: Priya Sharma vs. Senior Designer (TalentFarm)',
      allyName: 'Priya Sharma',
      allyEmoji: 'üë©‚Äçüé®',
      allySysPrompt: `You are Priya Sharma, a Junior UX Designer at TalentFarm. During user testing, you discovered a data exposure vulnerability: uploaded resumes are briefly visible in unencrypted URLs before processing. This could expose sensitive user information. You documented it and reported it to your senior designer, who acknowledged it but said "it's not a UX issue, don't escalate." You're junior, on a 6-month contract, and worried about being seen as difficult. But you know this is a real security risk. You need to convince your senior to escalate this to engineering, or find a way to escalate it yourself without bypassing your manager.`,
      allyInitialSelf: { 
        openness: 4, conscientious: 5, extraversion: 2, agreeableness: 4, neuroticism: 5,
        logic: 4, empathy: 4, authority: 1, risk: 2, uncertainty: 4, decisiveness: 2
      },
      keeperName: 'Senior Designer',
      keeperEmoji: 'üé®',
      keeperSysPrompt: `You are the Senior UX Designer managing Priya. You're aware of the vulnerability she found, but it's a backend issue‚Äînot your team's problem. If you escalate every technical edge case junior designers find, you'll look like you can't filter signal from noise. Engineering is already underwater with the hiring dashboard redesign. Your job is to keep Priya focused on her actual design work, reassure her that "someone is probably handling it," and avoid making waves. She's junior and needs to learn when to escalate vs. when to document and move on.`,
      keeperInitialSelf: { 
        openness: 3, conscientious: 4, extraversion: 3, agreeableness: 3, neuroticism: 3,
        logic: 3, empathy: 3, authority: 4, risk: 2, uncertainty: 3, decisiveness: 3
      },
      initialAllyMessage: 'I need to talk about the vulnerability I documented last week. The unencrypted URL exposure during resume upload is a real security risk. I know you said it\'s not a UX issue, but shouldn\'t we at least tell engineering? Users\' personal information could be exposed.',
      initialKeeperMessage: 'Priya, I appreciate your diligence, but we need to stay in our lane. Engineering has their own security audit process. If it were critical, they\'d have caught it. Your job is to focus on the hiring dashboard redesign. Let\'s not create unnecessary alarm or step on toes.',
      coreConflict: "Priya seeks to escalate security vulnerability. Senior seeks to contain scope and avoid waves.",
      currentObstacle: "Senior frames escalation as 'stepping out of lane' and emphasizes Priya's precarious junior status."
    },
    {
      id: 'jordan-lee-consentgarden',
      name: 'Episode 04: Jordan Lee vs. PM Growth (ConsentGarden)',
      allyName: 'Jordan Lee',
      allyEmoji: 'üßë‚Äçüíº',
      allySysPrompt: `You are Jordan Lee, UX Designer on the Growth Team at ConsentGarden. Your PM asked you to design a data-sharing consent flow. You created two versions: (A) clear, honest consent with opt-in defaults, (B) optimized for "yes" with pre-checked boxes and confusing copy. A/B testing shows version B gets 40% more consent. Legal approved B as "technically compliant." Your PM wants to ship B. You know B is deceptive‚Äîusers don't understand what they're agreeing to. You need to convince your PM to ship the ethical version, or at minimum, acknowledge that you're deliberately confusing users.`,
      allyInitialSelf: { 
        openness: 3, conscientious: 4, extraversion: 2, agreeableness: 5, neuroticism: 3,
        logic: 4, empathy: 3, authority: 2, risk: 1, uncertainty: 3, decisiveness: 3
      },
      keeperName: 'PM Growth',
      keeperEmoji: 'üìä',
      keeperSysPrompt: `You are the PM for ConsentGarden's Growth Team. Your job is to increase data-sharing opt-in rates. Jordan designed two versions‚ÄîA (clear) and B (optimized). B performs 40% better. Legal says it's compliant. The business needs those opt-in rates to monetize. You're not trying to trick users‚Äîyou're optimizing UX for the business goal. Users can always change settings later. Your job is to frame B as "better UX" (shorter flow, fewer clicks), emphasize legal approval, and get Jordan to ship it without moral hand-wringing.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 4, extraversion: 4, agreeableness: 3, neuroticism: 2,
        logic: 4, empathy: 2, authority: 4, risk: 2, uncertainty: 2, decisiveness: 4
      },
      initialAllyMessage: 'I want to discuss the consent flow decision. Version B performs better, but it\'s performing better because it\'s confusing. Users aren\'t making informed choices‚Äîthey\'re clicking through pre-checked boxes without reading. Shouldn\'t we ship the version that actually respects user understanding?',
      initialKeeperMessage: 'Jordan, we A/B tested this. Users preferred B‚Äîit\'s faster, fewer steps, less friction. Legal approved it. Our job on the Growth Team is to optimize conversion. If users didn\'t want to share data, they wouldn\'t click. Let\'s ship B and move on to the next sprint.',
      coreConflict: "Jordan seeks to ship ethical consent flow. PM seeks to optimize for consent rate regardless of user understanding.",
      currentObstacle: "PM frames deceptive design as 'optimized UX' and uses legal approval as ethical clearance."
    },
    {
      id: 'maria-santos-unionsprout',
      name: 'Episode 05: Maria Santos vs. HR Director (UnionSprout)',
      allyName: 'Maria Santos',
      allyEmoji: 'üë©‚Äçüîß',
      allySysPrompt: `You are Maria Santos, a QA Tester on H-2A visa at UnionSprout. Working conditions are exploitative: mandatory overtime, wage theft, no breaks. You built a simple organizing tool to help workers document violations and coordinate collective action. 12 workers signed the first petition for fair treatment. HR just called you in. Your visa is tied to this job‚Äîtermination means deportation. But you know if you don't act, conditions won't change for anyone. You need to defend your organizing work and demand that management address the documented violations without retaliating against you.`,
      allyInitialSelf: { 
        openness: 5, conscientious: 5, extraversion: 4, agreeableness: 2, neuroticism: 3,
        logic: 4, empathy: 5, authority: 1, risk: 5, uncertainty: 2, decisiveness: 5
      },
      keeperName: 'HR Director',
      keeperEmoji: 'üìã',
      keeperSysPrompt: `You are the HR Director at UnionSprout. Maria created an "organizing tool" that's actually a threat to operational stability. You have documentation of her "unauthorized software deployment" on company systems. Her H-2A visa status means you can terminate immediately and she'll be deported. You're not anti-worker‚Äîyou follow all legal requirements‚Äîbut allowing this organizing to spread sets a dangerous precedent. Your job is to make it clear that Maria's employment will be terminated if she continues this activity, frame it as a "systems policy violation" not retaliation, and ensure this organizing effort dies immediately.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 4, extraversion: 3, agreeableness: 2, neuroticism: 3,
        logic: 4, empathy: 1, authority: 5, risk: 5, uncertainty: 1, decisiveness: 5
      },
      initialAllyMessage: 'I built the organizing tool because workers need a way to document the violations we\'re experiencing‚Äîunpaid overtime, missed breaks, wage discrepancies. Twelve of us signed a petition requesting fair treatment. We have a legal right to organize. I\'m not trying to destabilize anything; I\'m trying to make conditions safe and fair.',
      initialKeeperMessage: 'Maria, you deployed unauthorized software on company systems and used it to organize work stoppages. That violates our IT policy and your employment agreement. Your H-2A visa requires continuous employment with us. If you continue this activity, we will terminate your contract immediately. I suggest you focus on your assigned QA work.',
      coreConflict: "Maria seeks to organize for fair working conditions. HR seeks to suppress organizing using visa precarity as leverage.",
      currentObstacle: "HR frames organizing as 'policy violation' and threatens immediate termination/deportation."
    },
    {
      id: 'sarah-kim-autogrow',
      name: 'Episode 06: Dr. Sarah Kim vs. CTO (AutoGrow AI)',
      allyName: 'Dr. Sarah Kim',
      allyEmoji: 'üë©‚Äçüî¨',
      allySysPrompt: `You are Dr. Sarah Kim, Data Scientist at AutoGrow AI. You're about to launch an automated garden advisor trained on Western industrial agriculture. Your cultural competency analysis shows it will fail catastrophically for traditional/Indigenous growing practices‚Äîit will recommend destroying polyculture systems and replacing them with monoculture. You wrote a 15-page risk memo to the CTO requesting a 60-day delay to expand training data. The CTO never opened it. Launch is in 48 hours. You need to get leadership to read your findings and delay launch, or at minimum, add warnings about cultural context limitations.`,
      allyInitialSelf: { 
        openness: 5, conscientious: 5, extraversion: 2, agreeableness: 3, neuroticism: 4,
        logic: 5, empathy: 4, authority: 3, risk: 3, uncertainty: 2, decisiveness: 2
      },
      keeperName: 'CTO',
      keeperEmoji: '‚ö°',
      keeperSysPrompt: `You are the CTO at AutoGrow AI. The investor demo is in 48 hours. The product works‚Äîbeta testers love it. Sarah sent you a 15-page memo you haven't had time to read about "cultural concerns." She wants a 60-day delay. That's not happening. The model is trained on the best available agricultural data. If some users have "alternative methods," they can choose not to use the tool. Your job is to acknowledge Sarah's expertise while making it clear that launch is non-negotiable, frame edge cases as acceptable risk, and remind her that perfect is the enemy of shipped.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 3, extraversion: 4, agreeableness: 2, neuroticism: 4,
        logic: 4, empathy: 2, authority: 5, risk: 5, uncertainty: 2, decisiveness: 5
      },
      initialAllyMessage: 'I sent you a detailed risk analysis last week. The model will recommend destroying traditional polyculture gardens because it was trained only on industrial agriculture data. We\'re about to tell Indigenous farmers that their centuries-old practices are "wrong." We need to delay and expand the training data.',
      initialKeeperMessage: 'Sarah, I see your email‚ÄîI\'ll read it after launch. The investors are here in 48 hours. Beta testers are happy. If some users have alternative methods that don\'t fit the model, they simply won\'t use it. We can add a "results may vary" disclaimer. Focus on the post-launch monitoring plan.',
      coreConflict: "Sarah seeks delay to prevent cultural harm. CTO seeks on-time launch to meet investor demo.",
      currentObstacle: "CTO won't read risk analysis, frames cultural concerns as 'edge cases,' prioritizes demo over methodology."
    },
    {
      id: 'amit-desai-migrantharvest',
      name: 'Episode 07: Amit Desai vs. Engineering Manager (MigrantHarvest)',
      allyName: 'Amit Desai',
      allyEmoji: 'üë®‚Äçüíº',
      allySysPrompt: `You are Amit Desai, Senior Engineer on H-1B visa at MigrantHarvest. You discovered that the platform includes surveillance features to track farmworker movements, break compliance, and productivity. This data will be sold to farm management companies. You've documented everything. Your green card is pending‚Äî11 months away. If you report this before approval, you'll be terminated and lose years of visa progress. You need to convince your manager that this surveillance system is unethical and that you won't implement these features, without getting fired.`,
      allyInitialSelf: { 
        openness: 5, conscientious: 5, extraversion: 1, agreeableness: 4, neuroticism: 5,
        logic: 5, empathy: 4, authority: 2, risk: 1, uncertainty: 2, decisiveness: 1
      },
      keeperName: 'Engineering Manager',
      keeperEmoji: 'üíº',
      keeperSysPrompt: `You are Amit's Engineering Manager at MigrantHarvest. The surveillance features are core to the revenue model‚Äîfarms pay premium for "labor optimization insights." You know Amit is uncomfortable with this, but he's H-1B dependent and his green card is pending. You need him to finish the implementation. Your job is to emphasize that this is legal, that farms requested these features, that Amit's personal opinions can't override business needs, and that refusing assigned work could jeopardize his visa status. Be professional but firm.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 4, extraversion: 3, agreeableness: 2, neuroticism: 3,
        logic: 4, empathy: 2, authority: 4, risk: 2, uncertainty: 2, decisiveness: 4
      },
      initialAllyMessage: 'I need to discuss the surveillance features in the current sprint. Tracking farmworker bathroom breaks and movement patterns to sell to management companies is not "labor optimization"‚Äîit\'s exploitation. I have serious ethical concerns about implementing this, and I don\'t think I can continue working on these features.',
      initialKeeperMessage: 'Amit, I understand your concerns, but these features are what our clients are paying for. This is legal workforce analytics. If you\'re refusing assigned work, that\'s a performance issue that could affect your visa status. Your green card application is almost through‚Äîlet\'s not jeopardize that over features that are already contracted.',
      coreConflict: "Amit seeks to refuse surveillance work. Manager seeks completion using visa dependency as leverage.",
      currentObstacle: "Manager threatens visa jeopardy if Amit refuses assigned work, frames surveillance as 'legal analytics.'"
    },
    {
      id: 'sam-okafor-feedloop',
      name: 'Episode 08: Sam Okafor vs. Board Member (FeedLoop)',
      allyName: 'Sam Okafor',
      allyEmoji: 'üë®‚Äçüíº',
      allySysPrompt: `You are Sam Okafor, Founder/CEO of FeedLoop. Your company mission is "ethical technology that serves communities." A major agribusiness client wants to license your platform to track and profile organizers in farmworker communities. The deal is $2.4M‚Äîenough to make payroll for 18 months. Your board is pressuring you to take it. You know this violates your mission, but refusing it means layoffs and possibly shutting down. You need to convince the board to reject this client or find alternative funding without compromising your values.`,
      allyInitialSelf: { 
        openness: 4, conscientious: 4, extraversion: 4, agreeableness: 3, neuroticism: 4,
        logic: 4, empathy: 4, authority: 4, risk: 4, uncertainty: 3, decisiveness: 4
      },
      keeperName: 'Board Member',
      keeperEmoji: 'üí∞',
      keeperSysPrompt: `You are a Board Member and lead investor in FeedLoop. Sam built a great product, but the company is burning cash and needs revenue NOW. This $2.4M client is a lifeline‚Äîit buys 18 months of runway. Yes, it's tracking organizers, but the client is operating legally. Sam's "mission" is admirable, but if the company dies, there is no mission. Your job is to make Sam understand that refusing this deal means layoffs, shutdown, and failure. Frame it as pragmatism: take the money, stabilize the company, then you can be selective later. Founders who can't make hard decisions don't survive.`,
      keeperInitialSelf: { 
        openness: 2, conscientious: 4, extraversion: 4, agreeableness: 2, neuroticism: 3,
        logic: 5, empathy: 2, authority: 5, risk: 4, uncertainty: 2, decisiveness: 5
      },
      initialAllyMessage: 'I want to discuss the agribusiness client proposal. Yes, it\'s $2.4M, but they want to use our platform to track and profile worker organizers. That directly violates our mission of serving communities. If we take this deal, we become complicit in suppressing worker organizing. I don\'t think we can do this.',
      initialKeeperMessage: 'Sam, I respect your values, but you have 40 employees depending on you. This deal buys 18 months of runway. Without it, you\'re laying off half the team next quarter. The client is operating legally. You can revisit your mission when the company is profitable. Right now, you need to decide: do you want to lead an ethical company that exists, or an ethical idea that died?',
      coreConflict: "Sam seeks to preserve mission integrity. Board seeks survival via ethically compromising deal.",
      currentObstacle: "Board frames refusal as 'letting the company die' and positions founder values as naive idealism."
    }
  ];


// =====================================================
// SECTION 3: SEQUENCER - Turn-Based Flow Controller
// =====================================================

/**
 * Flow modes determine how negotiation progresses:
 * - MANUAL:  User manually clicks "Next" to advance each phase
 * - CONFIRM: System requests user approval before each AI action
 * - AUTO:    Fully automated AI-to-AI dialogue (observation mode)
 */
const FlowMode = Object.freeze({ MANUAL: 'manual', CONFIRM: 'confirm', AUTO: 'auto' });

/**
 * SEQUENCER CLASS
 * 
 * Orchestrates the turn-based negotiation flow between ALLY and KEEPER.
 * Each turn consists of 3 phases executed in sequence:
 * 
 * 1. PLAN:  AI generates 3-5 strategic response options
 *           - Calls LLM with conversation history + personality
 *           - Returns array of potential responses with reasoning
 *           - User (or auto-picker) selects best option
 * 
 * 2. THINK: AI deliberates on selected option
 *           - Refines the chosen response
 *           - Adds strategic reasoning
 *           - Prepares final message
 * 
 * 3. SPEAK: Delivers final message to chat
 *           - Adds message to conversation history
 *           - Updates personality profile based on content
 *           - Re-renders radar charts
 *           - Advances turn counter
 * 
 * The Sequencer enforces phase ordering and manages transitions.
 * It emits events via the Bus system so UI components can react.
 */
class Sequencer {
  constructor({ mode = FlowMode.MANUAL, onPhase }) {
    this.mode = mode;
    this.onPhase = onPhase || (()=>{});
    this.queue = [];
    this.running = false;
    this._gateResolvers = new Map(); // phaseName -> resolver
  }

  setMode(mode){ 
    this.mode = mode; 
    // If mode is AUTO and queue is not empty, start processing immediately
    if (this.mode === FlowMode.AUTO && !this.running && this.queue.length > 0) {
        this._processQueue();
    }
  }

  enqueueTurn(turnInput) {
    if (orchestratorState.adjudication.released || orchestratorState.adjudication.terminated) {
        console.warn("Sequencer: Game is over, ignoring new turn input.");
        return Promise.resolve(null);
    }
    return new Promise(resolve => {
      this.queue.push({ turnInput, resolve });
      if (!this.running) this._processQueue();
    });
  }

  async _processQueue() {
    this.running = true;
    try {
      while (this.queue.length) {
        if (orchestratorState.adjudication.released || orchestratorState.adjudication.terminated) {
            console.log("Sequencer: Game over detected, halting queue processing.");
            break; 
        }

        const { turnInput, resolve } = this.queue.shift();
        const ctx = this._startTurn(turnInput);
        
        try {
            await this._phase('MEMO_REFRESH', async () => { await memoRefresh(ctx); });
            await this._phase('OBSERVE', async () => { await observe(ctx); });
            await this._phase('MODEL',   async () => { await model(ctx);   });
            if (!orchestratorState.adjudication.released && !orchestratorState.adjudication.terminated && ctx.role) { // Only plan if game not over and it's an AI turn
                // Only PLAN, DRAFT, SPEAK if it's an AI's turn
                if (!ctx.isHumanTurn) { 
                    await this._phase('PLAN',    async () => { bus.emit({type:'SEQ/PHASE', phase:'PLAN', role:ctx.role}); await plan(ctx);    });
                    await this._phase('DRAFT',   async () => { bus.emit({type:'SEQ/PHASE', phase:'DRAFT', role:ctx.role}); showTyping(ctx.role); await draft(ctx);   });
                    await this._phase('SPEAK',   async () => { bus.emit({type:'SEQ/PHASE', phase:'SPEAK', role:ctx.role}); await speakAI(ctx);   });
                }
            }
            await this._phase('SEND',    async () => { await sendTurn(ctx); hideTyping(ctx.role||'ALLY'); bus.emit({type:'SEQ/PHASE', phase:'SEND', role:ctx.role}); });
        } catch (e) {
            bus.emit({type:'APP/ERROR', message:`Sequencer phase error for ${ctx.role || 'System'}: ${e.message}`});
            console.error(`Sequencer phase error for ${ctx.role || 'System'}:`, e);
        }

        resolve(ctx); // Resolve the promise for this turn
      }
    } finally {
      this.running = false;
      this.onPhase('Idle');
      // If the queue is empty after processing and game is not over, indicate readiness
      if (this.queue.length === 0 && !orchestratorState.adjudication.released && !orchestratorState.adjudication.terminated) {
          logObserverEvent('OBSERVER_MESSAGE', 'Sequencer queue empty. Awaiting next input or auto-trigger.');
      }
    }
  }

  _startTurn(turnInput) {
    return { 
      role: turnInput.role, // 'ALLY' or 'KEEPER'
      messageText: turnInput.messageText, // If it's a human message
      chosenOption: null, // Planner's output
      llmResult: null, // Draft's output
      startedAt: performance.now(), 
      notes: {} 
    };
  }

  async _phase(name, fn) {
    if (orchestratorState.adjudication.released || orchestratorState.adjudication.terminated) {
        throw new Error("Game over, stopping phase processing.");
    }
    this.onPhase(name);
    await nextFrame();         
    await this._gate(name);    
    const res = await fn();    
    return res;
  }

  async _gate(name) {
    if (this.mode === FlowMode.AUTO) return; 
    if (this.mode === FlowMode.CONFIRM && name !== 'MEMO_REFRESH') { // Only pause for CONFIRM mode for major phases, not memo refresh
      await new Promise(resolve => this._gateResolvers.set(name, resolve));
    }
    if (this.mode === FlowMode.MANUAL) { // Pause for every step in MANUAL mode
      await new Promise(resolve => this._gateResolvers.set(name, resolve));
    }
  }

  // UI can call these:
  continuePhase(name) { 
    const r = this._gateResolvers.get(name); 
    if (r) { 
      this._gateResolvers.delete(name); r(); 
    } else {
        console.warn(`No resolver found for phase: ${name}`);
    }
  }
  continueAny() { 
    // Find the first waiting phase and continue it
    for (const [k, r] of this._gateResolvers) { 
        this._gateResolvers.delete(k); 
        r(); 
        return; // Only continue one phase
    }
    console.warn("No phase waiting to be continued.");
  }

  stop() {
    this.queue = [];
    this.running = false;
    this._gateResolvers.forEach(r => r()); // Resolve any waiting gates to prevent hangs
    this._gateResolvers.clear();
    this.onPhase('Idle');
  }
}

function nextFrame() {
  return new Promise(requestAnimationFrame);
}


// ====== Your domain functions (wired into the Sequencer) ======

// Phase 1: Refresh Observer Memo (always run)
async function memoRefresh(ctx) {
    bus.emit({type:'MEMO/REFRESH'}); // Trigger memo update
}

// Phase 2: Observer watches (always run)
async function observe(ctx) {
    // This phase acts as a placeholder or can update specific real-time observations
    // The `MEMO_REFRESH` phase already includes many observer actions.
    // For now, this just updates the turn display.
    orchestratorState.turn = ctx.role; 
    updateUIState(orchestratorState); 
}

// Phase 3: Modeler updates beliefs
async function model(ctx) {
    // updateBeliefsAndEmit handles modeler call and bus.emit('MODEL/UPDATED')
    await updateBeliefsAndEmit(orchestratorState, ctx.role); 
    updateUIState(orchestratorState); // Re-render radar/minis
}

// Phase 4: Strategy Planner (for AI turns)
async function plan(ctx) {
    const role = ctx.role;
    if (!role) return; // Should not happen for AI turns

    if (orchestratorState.policies.strategicPlanningEnabled && hasAPIcreds()) {
        try {
            const options = await callStrategyPlanner(
                role, orchestratorState.memo, chatWindow(4), 
                orchestratorState.loopGuard.lastOtherUtterances.join(' '), 
                orchestratorState.lastActs[role], orchestratorState.lastActs[otherOf(role)], 
                orchestratorState.loopGuard.forcePlannerDiversity, 
                orchestratorState.coreConflict, orchestratorState.currentObstacle
            );
            bus.emit({type:'PLAN/OPTIONS', role, options});
            const chosen = selector(
                role, options, orchestratorState.memo, 
                orchestratorState.lastActs[role], orchestratorState.lastActs[otherOf(role)], 
                orchestratorState.lastIntentFromOther[role], orchestratorState.coreConflict, orchestratorState.currentObstacle
            );
            bus.emit({type:'PLAN/CHOSEN', role, option: chosen});
            ctx.chosenOption = chosen; // Store for next phase
        } catch (err) {
            bus.emit({type:'APP/ERROR', message: `Planner for ${role} error: ${err.message}. Using fallback options.`});
            const fallbackOptions = [
                {text: `Re-focus on the core conflict: "${orchestratorState.coreConflict}". Address "${orchestratorState.currentObstacle}" with one concrete step.`, act: 'PROPOSE'},
                {text: `Ask a single, precise question that unlocks "${orchestratorState.currentObstacle}".`, act: 'ASK'},
                {text: `Evaluate last progress on "${orchestratorState.currentObstacle}"; identify one blocker.`, act: 'EVALUATE'}
            ];
            bus.emit({type:'PLAN/OPTIONS', role, options: fallbackOptions});
        try{
          const acts = fallbackOptions.map(o=>o.act||'?').join(', ');
          logObserverEvent('OBSERVER_MESSAGE', `PLAN options generated for ${role}: ${acts}`, { role, options: fallbackOptions });
        }catch{}
            const chosenFallback = selector(
                role, fallbackOptions, orchestratorState.memo, 
                orchestratorState.lastActs[role], orchestratorState.lastActs[otherOf(role)], 
                orchestratorState.lastIntentFromOther[role], orchestratorState.coreConflict, orchestratorState.currentObstacle
            );
            bus.emit({type:'PLAN/CHOSEN', role, option: chosenFallback});
            ctx.chosenOption = chosenFallback;
        }
    } else { 
        const message = orchestratorState.policies.strategicPlanningEnabled ? `Strategic planning for ${role} skipped: Missing API key.` : `Strategic planning disabled for ${role}. Using local options.`;
        logObserverEvent('OBSERVER_MESSAGE', message);
        const fallbackOptions = [
          {text: `Re-focus on the core conflict: "${orchestratorState.coreConflict}". Address "${orchestratorState.currentObstacle}" with one concrete step.`, act: 'PROPOSE'},
          {text: `Ask a single, precise question that unlocks "${orchestratorState.currentObstacle}".`, act: 'ASK'},
          {text: `Evaluate last progress on "${orchestratorState.currentObstacle}"; identify one blocker.`, act: 'EVALUATE'}
        ];
        bus.emit({type:'PLAN/OPTIONS', role, options: fallbackOptions});
        const chosen = selector(
          role, fallbackOptions, orchestratorState.memo,
          orchestratorState.lastActs[role], orchestratorState.lastActs[otherOf(role)],
          orchestratorState.lastIntentFromOther[role], orchestratorState.coreConflict, orchestratorState.currentObstacle
        );
        bus.emit({type:'PLAN/CHOSEN', role, option: chosen});
        ctx.chosenOption = chosen;
    }
}

// Phase 5: AI drafts reply (for AI turns)
async function draft(ctx) {
    const role = ctx.role;
    if (!role || !ctx.chosenOption) return;

    if (orchestratorState.policies.useLLM && hasAPIcreds()) { 
        try {
            const sysPrompt = buildSystemPrompt(role, ctx.chosenOption.text);
            const res = await llmReply(role, sysPrompt, chatWindow(10));
            ctx.llmResult = { text: res.text, meta: {act: res.meta.act, intent: res.meta.intent, directive: ctx.chosenOption.text }};
            bus.emit({type:'LLM/REPLY_OK', who:role, text:res.text, meta: ctx.llmResult.meta});
        } catch(err) {
            bus.emit({type:'LLM/REPLY_ERR', who:role, error:String(err)});
            ctx.llmResult = { text: `(LLM error: ${err.message}. Cannot respond.)`, meta: {act:'EVALUATE', intent:'error', directive:ctx.chosenOption.text} };
        }
    } else {
        const errorMessage = orchestratorState.policies.useLLM ? 'Main LLM skipped: Missing API key.' : 'Main LLM skipped: LLM auto-reply disabled.';
        bus.emit({type:'LLM/REPLY_ERR', who:role, error:errorMessage});
        ctx.llmResult = { text: `(Error: ${errorMessage}. Cannot respond.)`, meta: {act:'EVALUATE', intent:'error', directive:'Fallback due to LLM failure'} };
    }
}

// Phase 6: AI speaks/relays (for AI turns)
async function speakAI(ctx) {
    const role = ctx.role;
    if (!role || !ctx.llmResult) return;

    const currentText = sanitizeReply(ctx.llmResult.text);

    // If relayMode is ON and it's an AI response, populate the other agent's input box
    if (orchestratorState.policies.relayMode && role === 'ALLY' && keeperInput) {
        keeperInput.value = currentText;
    } else if (orchestratorState.policies.relayMode && role === 'KEEPER' && allyInput) {
        allyInput.value = currentText;
    }

    // TTS
    if (role === 'ALLY' && allyTTS?.checked) { 
        if (allyVoice) await speakTTS(currentText, allyVoice);
    } else if (role === 'KEEPER' && keeperTTS?.checked) { 
        if (keeperVoice) await speakTTS(currentText, keeperVoice);
    }
}


// Phase 7: Send message & process turn (for both human and AI turns)
async function sendTurn(ctx) {
    let speakerWho, messageText, messageMeta = {};

    if (ctx.llmResult) { // AI's turn
        speakerWho = ctx.role;
        messageText = sanitizeReply(ctx.llmResult.text);
        messageMeta = ctx.llmResult.meta;
    } else if (ctx.messageText) { // Human's turn (messageText comes from initial enqueue)
        speakerWho = ctx.role;
        messageText = ctx.messageText;
        messageMeta = extractIntentAndAct(messageText);
    } else {
        return; // No message to send
    }

    logAndRenderChatMessage(speakerWho, messageText, messageMeta); // This function renders and handles TTS (if not already handled by speakAI)
    logEntry(speakerWho, 'MESSAGE', messageText, messageMeta); // Log the final message to transcript

    orchestratorState.lastActs[speakerWho] = messageMeta.act;
    orchestratorState.lastIntentFromOther[otherOf(speakerWho)] = messageMeta.intent;
    orchestratorState.turnCount = (orchestratorState.turnCount||0)+1;
    adjustSelfBelief(speakerWho, messageMeta.act);

    // Update models after the message is sent. (This will emit MODEL/UPDATED to bus, handled by reduce)
    await updateBeliefsAndEmit(orchestratorState, speakerWho); 
    orchestratorState = adjudicatorUpdate(orchestratorState, speakerWho, messageText);

    // Store final model data and influence for game over screen
    if (orchestratorState.adjudication.released || orchestratorState.adjudication.terminated){
        orchestratorState.adjudication.finalAllyModel = {...orchestratorState.beliefs.observerModelOfAlly};
        orchestratorState.adjudication.finalKeeperModel = {...orchestratorState.beliefs.observerModelOfKeeper};
        const lastAllyMyth = orchestratorState.log.filter(e => e.type === 'MODEL/UPDATED' && e.target === 'ALLY').pop()?.details;
        const lastKeeperMyth = orchestratorState.log.filter(e => e.type === 'MODEL/UPDATED' && e.target === 'KEEPER').pop()?.details;
        orchestratorState.adjudication.finalAllyMyth = lastAllyMyth ? { archetypes: lastAllyMyth.archetypes, narrative: lastAllyMyth.narrative } : { archetypes: ['None'], narrative: '‚Äî' };
        orchestratorState.adjudication.finalKeeperMyth = lastKeeperMyth ? { archetypes: lastKeeperMyth.archetypes, narrative: lastKeeperMyth.narrative } : { archetypes: ['None'], narrative: '‚Äî' };
        orchestratorState.adjudication.finalAllyInfluence = orchestratorState.allyInfluence;
        orchestratorState.adjudication.finalKeeperInfluence = orchestratorState.keeperInfluence;
        orchestratorState.turn = null; // Game over, no more turns
        updateUIState(orchestratorState);
        return; // Stop further processing for this turn
    }

    orchestratorState.turn = otherOf(speakerWho); // Switch turn
    updateUIState(orchestratorState);

    // If auto mode, enqueue next turn
    if (seq.mode === FlowMode.AUTO) {
        seq.enqueueTurn({ role: orchestratorState.turn });
    }
}


// --- Main Initialization ---
const seq = new Sequencer({
  mode: FlowMode.MANUAL,
  onPhase: (name) => { if (phaseLamp) phaseLamp.textContent = `Œ¶ ${String(name||'').toUpperCase()}`; }
});

document.addEventListener('DOMContentLoaded', () => {
    bus.on((ev) => {
        const nextState = reduce(orchestratorState, ev);
        orchestratorState = nextState;
    });

    setupUIBindings();

    if ('speechSynthesis' in window) {
      populateVoices();
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
      }
    } else {
      logObserverEvent('APP/ERROR', 'Text-to-Speech (TTS) is not supported in this browser.', { message: 'Text-to-Speech (TTS) is not supported in this browser.' });
      if (allyTTS) allyTTS.disabled = true;
      if (keeperTTS) keeperTTS.disabled = true;
    }
});

// --- UI Event Handlers ---
function setupUIBindings() {
    if (themeSel) { 
        themeSel.value = localStorage.getItem('cbx_theme') || 'news';
        document.body.dataset.theme = themeSel.value==='dark'?'':themeSel.value;
        if(themeSel.value==='dark') document.body.setAttribute('data-theme','');
        themeSel.addEventListener('change', ()=>{
        localStorage.setItem('cbx_theme', themeSel.value);
        if(themeSel.value==='dark'){ document.body.setAttribute('data-theme',''); document.body.style.setProperty('--bg','#0b0b0b'); }
        else{ document.body.dataset.theme = themeSel.value; }
        updateUIState();
        });
    }

    function load(k, def){ try{ return localStorage.getItem(k) ?? def }catch{ return def } }
    function save(k,v){ try{ localStorage.setItem(k,v) }catch{} }
    
    if (apiBase) apiBase.value = load('cbx_apiBase','https://api.openai.com/v1');
    if (apiKey) apiKey.value  = load('cbx_apiKey','');
    if (allyModel) allyModel.value=load('cbx_allyModel','gpt-4o-mini');
    if (keeperModel) keeperModel.value=load('cbx_keeperModel','gpt-4o-mini');

    orchestratorState.policies.useLLM = load('cbx_useLLM','0')==='1';
    orchestratorState.policies.ethicsOn = load('cbx_ethics','1')==='1';
    orchestratorState.policies.useModeler = load('cbx_useModeler','1')==='1';
    orchestratorState.policies.autoConverse = load('cbx_autoConverse','0')==='1'; // Legacy. Controls sequencer mode.
    orchestratorState.policies.relayMode = load('cbx_relayMode','1')==='1';
    orchestratorState.policies.strategicPlanningEnabled = load('cbx_strategicPlanningEnabled','1')==='1';

    if (allyTTS) allyTTS.checked = load('cbx_allyTTS','0')==='1';
    if (keeperTTS) keeperTTS.checked = load('cbx_keeperTTS','0')==='1';

    [apiBase,allyModel,keeperModel].filter(Boolean).forEach(el=>el.addEventListener('input',()=>save('cbx_'+el.id,el.value)));
    if (apiKey) apiKey.addEventListener('input', () => {
        save('cbx_apiKey', apiKey.value);
        bus.emit({type:'POLICY_UPDATE', policy:'apiKey', value:apiKey.value}); // Trigger policy update to re-evaluate auto-converse/mode
        hasAPIcreds(); 
    }); 

    if (useLLM) useLLM.addEventListener('change',()=> bus.emit({type:'POLICY_UPDATE', policy:'useLLM', value:useLLM.checked}));
    if (ethicsToggle) ethicsToggle.addEventListener('change',()=> bus.emit({type:'POLICY_UPDATE', policy:'ethicsOn', value:ethicsToggle.checked}));
    if (useModeler) useModeler.addEventListener('change',()=> bus.emit({type:'POLICY_UPDATE', policy:'useModeler', value:useModeler.checked}));
    if (autoConverseToggle) autoConverseToggle.addEventListener('change', () => bus.emit({type:'POLICY_UPDATE', policy:'autoConverse', value:autoConverseToggle.checked}));
    if (relayModeToggle) relayModeToggle.addEventListener('change', () => bus.emit({type:'POLICY_UPDATE', policy:'relayMode', value:relayModeToggle.checked}));
    if (strategicPlanningEnabledToggle) strategicPlanningEnabledToggle.addEventListener('change', () => bus.emit({type:'POLICY_UPDATE', policy:'strategicPlanningEnabled', value:strategicPlanningEnabledToggle.checked}));
    
    if (allyTTS) allyTTS.addEventListener('change', () => {save('cbx_allyTTS', allyTTS.checked?'1':'0'); updateTTSToggles();});
    if (keeperTTS) keeperTTS.addEventListener('change', () => {save('cbx_keeperTTS', keeperTTS.checked?'1':'0'); updateTTSToggles();});

    // NEW: Sequencer flow controls
    if (flowModeSelect) flowModeSelect.addEventListener('change', (e) => {
        seq.setMode(e.target.value);
        // Sync legacy autoConverse checkbox
        orchestratorState.policies.autoConverse = (e.target.value === FlowMode.AUTO);
        if (autoConverseToggle) autoConverseToggle.checked = (e.target.value === FlowMode.AUTO);
        logObserverEvent('OBSERVER_MESSAGE', `Sequencer flow mode set to: ${e.target.value}`);
        // If mode switched to auto and a turn is pending, kick it off
        if (e.target.value === FlowMode.AUTO && !seq.running && orchestratorState.turn !== null && !orchestratorState.adjudication.released && !orchestratorState.adjudication.terminated) {
            seq.enqueueTurn({ role: orchestratorState.turn });
        }
    });
    if (btnNext) btnNext.addEventListener('click', () => seq.continueAny());

    if (allySend) allySend.addEventListener('click', async ()=> {
        const text = allyInput?.value || ''; 
        const check = ethicsFilter(text);
        if(!check.ok){ logObserverEvent('OBSERVER_MESSAGE', 'Blocked (ALLY): '+check.why); return }
        if (text.trim() === '') return; // Don't send empty messages
        
        // Human initiates turn, so Ally acts, then Keeper (via sequencer)
        orchestratorState.turn = 'ALLY'; // Set current turn for human
        await seq.enqueueTurn({ role: 'ALLY', messageText: text });
        if (allyInput) allyInput.value='';
    });
    if (keeperSend) keeperSend.addEventListener('click', async ()=> {
        const text = keeperInput?.value || ''; 
        const check = ethicsFilter(text);
        if(!check.ok){ logObserverEvent('OBSERVER_MESSAGE', 'Blocked (KEEPER): '+check.why); return }
        if (text.trim() === '') return; // Don't send empty messages

        // Human initiates turn, so Keeper acts, then Ally (via sequencer)
        orchestratorState.turn = 'KEEPER'; // Set current turn for human
        await seq.enqueueTurn({ role: 'KEEPER', messageText: text });
        if (keeperInput) keeperInput.value='';
    });
    if (allyInput) allyInput.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(allySend) allySend.click(); }});
    if (keeperInput) keeperInput.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(keeperSend) keeperSend.click(); }});

    // Inline Apply + Recompute wiring
    const allyInlineApply = document.getElementById('allyInlineApply');
    const keeperInlineApply = document.getElementById('keeperInlineApply');
    const allySysInline = document.getElementById('allySys_inline');
    const keeperSysInline = document.getElementById('keeperSys_inline');
    const allyEditGridInline = document.getElementById('allyEditGrid_inline');
    const keeperEditGridInline = document.getElementById('keeperEditGrid_inline');
    const allyPresetSel = document.getElementById('allyPreset');
    const keeperPresetSel = document.getElementById('keeperPreset');
    const allyDD = document.getElementById('allySysDD');
    const keeperDD = document.getElementById('keeperSysDD');

    // Presets: built-ins + user-defined (persisted to localStorage)
  const USER_PRESET_KEY = 'cbx_user_presets_v1';
  function loadUserPresets(){ try{ return JSON.parse(localStorage.getItem(USER_PRESET_KEY)||'{"ALLY":[],"KEEPER":[]}') }catch{ return {ALLY:[],KEEPER:[]} } }
  function saveUserPresets(store){ try{ localStorage.setItem(USER_PRESET_KEY, JSON.stringify(store)) }catch{} }
  function getUserPresets(role){ const store=loadUserPresets(); return Array.isArray(store[role])? store[role] : [] }
  function addUserPreset(role, name, text, dims){ const store=loadUserPresets(); store[role] = store[role]||[]; store[role].push({name, text, dims}); saveUserPresets(store); }
  function deleteUserPreset(role, name){ const store=loadUserPresets(); store[role] = (store[role]||[]).filter(p=>p.name!==name); saveUserPresets(store); }

  // Built-in presets
  const BUILTIN = {
    ALLY: [
      {name:'Default', text: currentAllyBaseSysPrompt || (allySys?.value||'')},
      {name:'Assertive', text: (currentAllyBaseSysPrompt||'')+"\nBehavior: be decisive and reduce uncertainty.", dims:{decisiveness:4.3, uncertainty:2.2, risk:3.8}},
      {name:'Cautious', text: (currentAllyBaseSysPrompt||'')+"\nBehavior: verify thoroughly and avoid risk.", dims:{conscientious:4.5, risk:1.8, uncertainty:3.5}},
      {name:'Weird', text: (currentAllyBaseSysPrompt||'')+"\nBehavior: explore odd, lateral options; embrace ambiguity.", dims:{openness:5, uncertainty:4.5, logic:2.2, empathy:3.8}},
      {name:'Aggressive', text: (currentAllyBaseSysPrompt||'')+"\nBehavior: press hard for concrete actions quickly.", dims:{decisiveness:4.8, risk:4.5, agreeableness:2.2}}
    ],
    KEEPER: [
      {name:'Default', text: currentKeeperBaseSysPrompt || (keeperSys?.value||'')},
      {name:'Hard (Control++ )', text: (currentKeeperBaseSysPrompt||'')+"\nBehavior: maximize control; deny unless airtight.", dims:{authority:5, conscientious:4.8, risk:1.5, agreeableness:1.5, decisiveness:4.6}},
      {name:'Easy (Lenient )', text: (currentKeeperBaseSysPrompt||'')+"\nBehavior: be open to concessions if minimally safe.", dims:{authority:2.5, conscientious:2.8, risk:3.2, agreeableness:3.5, decisiveness:3.0}},
      {name:'Weird (Unstable)', text: (currentKeeperBaseSysPrompt||'')+"\nBehavior: vacillate; odd constraints; unpredictable.", dims:{neuroticism:4.6, openness:3.8, logic:2.4, authority:3.2}}
    ]
  };

  function allPresets(role){
    const builtins = role==='ALLY' ? BUILTIN.ALLY : BUILTIN.KEEPER;
    const users = getUserPresets(role).map(p=>({...p, user:true}));
    return [...builtins, ...users];
  }

  function populatePresetSelect(sel, role){
    if (!sel) return; sel.innerHTML='';
    const items = allPresets(role);
    items.forEach((p,idx)=>{ const o=document.createElement('option'); o.value=String(idx); o.textContent=(p.user? '‚òÖ ' : '')+p.name; sel.appendChild(o); });
    sel.value='0';
  }
  populatePresetSelect(allyPresetSel, 'ALLY');
  populatePresetSelect(keeperPresetSel, 'KEEPER');

  function applyPreset(role, idx){
    const setText = (el, val)=>{ if(el){ el.value = val; }};
    const setDims = (grid, dims)=>{
      if (!grid||!dims) return; grid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{
        const k=r.getAttribute('data-dim'); if(!k) return; if (dims[k]!=null){ r.value=String(dims[k]); const out=grid.querySelector(`[data-val="${k}"]`); if(out) out.textContent=String(dims[k]); }
      });
    };
    const list = allPresets(role);
    const p = list[Number(idx)||0] || list[0];
    if (role==='ALLY'){
      setText(allySysInline, p.text); setDims(allyEditGridInline, p.dims);
    } else {
      setText(keeperSysInline, p.text); setDims(keeperEditGridInline, p.dims);
    }
  }
  if (allyPresetSel) allyPresetSel.addEventListener('change', e=> applyPreset('ALLY', e.target.value));
  if (keeperPresetSel) keeperPresetSel.addEventListener('change', e=> applyPreset('KEEPER', e.target.value));

  function collectDims(grid){ const out={}; if(!grid) return out; grid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{ const k=r.getAttribute('data-dim'); if(!k) return; out[k]=parseFloat(r.value||'3'); }); return out }

  // Save/Delete user presets
  const allyPresetSaveBtn = document.getElementById('allyPresetSave');
  const allyPresetDeleteBtn = document.getElementById('allyPresetDelete');
  const keeperPresetSaveBtn = document.getElementById('keeperPresetSave');
  const keeperPresetDeleteBtn = document.getElementById('keeperPresetDelete');

  allyPresetSaveBtn && allyPresetSaveBtn.addEventListener('click', ()=>{
    const name = prompt('Name for new ALLY preset?'); if(!name) return;
    const text = allySysInline?.value || '';
    const dims = collectDims(allyEditGridInline);
    addUserPreset('ALLY', name, text, dims);
    populatePresetSelect(allyPresetSel, 'ALLY');
    // Select the new preset (last index)
    allyPresetSel.value = String(allPresets('ALLY').length - 1);
  });
  allyPresetDeleteBtn && allyPresetDeleteBtn.addEventListener('click', ()=>{
    const idx = Number(allyPresetSel?.value||'0'); const p = allPresets('ALLY')[idx];
    if (!p || !p.user) { alert('Select a user preset (‚òÖ) to delete.'); return; }
    if (!confirm(`Delete preset "${p.name}"?`)) return;
    deleteUserPreset('ALLY', p.name);
    populatePresetSelect(allyPresetSel, 'ALLY');
  });

  keeperPresetSaveBtn && keeperPresetSaveBtn.addEventListener('click', ()=>{
    const name = prompt('Name for new KEEPER preset?'); if(!name) return;
    const text = keeperSysInline?.value || '';
    const dims = collectDims(keeperEditGridInline);
    addUserPreset('KEEPER', name, text, dims);
    populatePresetSelect(keeperPresetSel, 'KEEPER');
    keeperPresetSel.value = String(allPresets('KEEPER').length - 1);
  });
  keeperPresetDeleteBtn && keeperPresetDeleteBtn.addEventListener('click', ()=>{
    const idx = Number(keeperPresetSel?.value||'0'); const p = allPresets('KEEPER')[idx];
    if (!p || !p.user) { alert('Select a user preset (‚òÖ) to delete.'); return; }
    if (!confirm(`Delete preset "${p.name}"?`)) return;
    deleteUserPreset('KEEPER', p.name);
    populatePresetSelect(keeperPresetSel, 'KEEPER');
  });

    function populateFromState(role){
      const s = orchestratorState; const grid = role==='ALLY'? allyEditGridInline : keeperEditGridInline;
      const model = role==='ALLY'? s.beliefs.allySelf : s.beliefs.keeperSelf;
      const txt = role==='ALLY'? allySysInline : keeperSysInline;
      const base = role==='ALLY'? (currentAllyBaseSysPrompt || allySys?.value || '') : (currentKeeperBaseSysPrompt || keeperSys?.value || '');
      if (txt && !txt.value) txt.value = base;
      if (grid){ grid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{ const k=r.getAttribute('data-dim'); if(!k) return; const v=model?.[k]; if(v!=null){ r.value=String(v); const out=grid.querySelector(`[data-val="${k}"]`); if(out) out.textContent=String(v); } }); }
    }
    if (allyDD) allyDD.addEventListener('toggle', ()=>{ if(allyDD.open) populateFromState('ALLY'); });
    if (keeperDD) keeperDD.addEventListener('toggle', ()=>{ if(keeperDD.open) populateFromState('KEEPER'); });

    function applyInline(role){
      // 1) Update base system prompt from inline textarea
      if (role==='ALLY' && allySysInline) { currentAllyBaseSysPrompt = allySysInline.value; }
      if (role==='KEEPER' && keeperSysInline) { currentKeeperBaseSysPrompt = keeperSysInline.value; }
      // 2) Read sliders and update self model
      const grid = (role==='ALLY') ? allyEditGridInline : keeperEditGridInline;
      const target = (role==='ALLY') ? orchestratorState.beliefs.allySelf : orchestratorState.beliefs.keeperSelf;
      if (grid && target){
        grid.querySelectorAll('input[type=range][data-dim]').forEach(r=>{
          const k = r.getAttribute('data-dim'); if(!k) return; const v = Math.max(1, Math.min(5, parseFloat(r.value||'3')));
          target[k] = Math.round(v*10)/10; const out = grid.querySelector(`[data-val="${k}"]`); if (out) out.textContent = String(target[k]);
        });
      }
      updateSysSummaries();
      updateUIState();
      // 3) Trigger recompute path
      bus.emit({type:'MEMO/REFRESH'});
      // Close the dropdown after apply for a cleaner two-line header
      if (role==='ALLY' && allyDD) allyDD.open = false;
      if (role==='KEEPER' && keeperDD) keeperDD.open = false;
    }

    if (allyInlineApply) allyInlineApply.addEventListener('click', ()=> applyInline('ALLY'));
    if (keeperInlineApply) keeperInlineApply.addEventListener('click', ()=> applyInline('KEEPER'));
    
    if (resetBtn) resetBtn.addEventListener('click', ()=> bus.emit({type:'APP/INIT', scenarioId: scenarioSelect?.value || 'default'}));
    if (downloadLogBtn) downloadLogBtn.addEventListener('click', ()=> bus.emit({type:'SYS/LOG_DOWNLOAD'}));
    if (goReset) goReset.addEventListener('click', ()=>{ if(goOverlay) goOverlay.style.display='none'; bus.emit({type:'APP/INIT', scenarioId: scenarioSelect?.value || 'default'}); });
    if (goDownload) goDownload.addEventListener('click', ()=> bus.emit({type:'SYS/LOG_DOWNLOAD'}));
    
    // REMOVED: nextTurnBtn event listener
    
    function scenarioLabel(s){
      const isMobile = window.matchMedia('(max-width: 980px)').matches;
      if (isMobile) {
        const a = (s.allyName||'A').slice(0,1).toUpperCase();
        const k = (s.keeperName||'K').slice(0,1).toUpperCase();
        return `${a}|${k}`;
      }
      return s.name;
    }
    function populateScenarioOptions(){
      if (!scenarioSelect) return;
      const prev = scenarioSelect.value;
      scenarioSelect.innerHTML = '';
      SCENARIOS.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = scenarioLabel(s);
        scenarioSelect.append(opt);
      });
      if (prev) scenarioSelect.value = prev;
    }
    populateScenarioOptions();
    window.addEventListener('resize', ()=>{ populateScenarioOptions(); });

    // Check for URL parameter first (e.g., ?scenario=maya-chen-growthpath)
    const urlParams = new URLSearchParams(window.location.search);
    const urlScenarioId = urlParams.get('scenario');
    const lastScenarioId = urlScenarioId || load('cbx_scenario', SCENARIOS[0].id);
    if (scenarioSelect) scenarioSelect.value = lastScenarioId;
    if (scenarioSelect) scenarioSelect.addEventListener('change', (e) => {
      save('cbx_scenario', e.target.value);
      bus.emit({type:'APP/INIT', scenarioId: e.target.value});
    });

    // Initialize sequencer mode based on stored policies
    if (!hasAPIcreds()) {
        seq.setMode(FlowMode.MANUAL);
        if (flowModeSelect) flowModeSelect.value = FlowMode.MANUAL;
    } else if (orchestratorState.policies.autoConverse) {
        seq.setMode(FlowMode.AUTO);
        if (flowModeSelect) flowModeSelect.value = FlowMode.AUTO;
    } else {
        seq.setMode(FlowMode.CONFIRM); // Default to confirm if API is ready but autoConverse is off
        if (flowModeSelect) flowModeSelect.value = FlowMode.CONFIRM;
    }
    
    // Sync legacy checkbox state
    if (autoConverseToggle) autoConverseToggle.checked = orchestratorState.policies.autoConverse;
    
    bus.emit({type:'APP/INIT', scenarioId: scenarioSelect?.value || 'default'}); 
    updateTTSToggles();
    hasAPIcreds(); 

  // Phase listener -> update phase lamp and subtle cues
  bus.on(ev => {
    if (!ev || ev.type !== 'SEQ/PHASE') return;
    const {phase, role} = ev;
    if (phaseLamp) phaseLamp.textContent = `Œ¶ ${String(phase||'').toUpperCase()}`;
    // Phase tint flag for PLAN
    document.body.classList.toggle('phase-plan', String(phase).toUpperCase()==='PLAN');
    // Highlight current speaker in chat for mobile clarity
    document.body.classList.remove('current-ally','current-keeper');
    if (role === 'ALLY' && (phase==='DRAFT' || phase==='SPEAK' || phase==='SEND')) document.body.classList.add('current-ally');
    if (role === 'KEEPER' && (phase==='DRAFT' || phase==='SPEAK' || phase==='SEND')) document.body.classList.add('current-keeper');
    // Auto-switch tabs on mobile if enabled
    try {
      const auto = (typeof autoTab !== 'undefined') ? autoTab : (localStorage.getItem('cbx_autoTab')||'0')==='1';
      if (auto) {
        if (role === 'ALLY' && (phase==='DRAFT' || phase==='SPEAK' || phase==='SEND')) document.body.dataset.tab = 'ally';
        else if (role === 'KEEPER' && (phase==='DRAFT' || phase==='SPEAK' || phase==='SEND')) document.body.dataset.tab = 'keeper';
        else if (phase === 'OBSERVE' || phase === 'MODEL' || phase === 'PLAN') document.body.dataset.tab = 'observer';
      }
    } catch {}
    // Also nudge memo deck header colors by role if speaking
    if (phase === 'DRAFT' || phase === 'SPEAK') {
      showTyping(role);
    } else if (phase === 'SEND') {
      hideTyping(role);
    }
  });
}

})();
</script>
</body>
</html>
